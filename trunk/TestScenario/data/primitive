
//SF Pipeline components command lines:
//define : used to define a new user defined temporary variable. Its scope is its own shader component. Its name 
//		must not conflict with other parameters and registers in component scope. May be written. May be used
//		in output (write) formulas 
//use : indicates the name of an input register used by this component. It is used in output (write) formulas
//write : indicates the name of an output register or of a temporary defined variable which is written by a 
//		component and its formula. 
//param : a user defined parameters which is used in output (write) formulas. 
//include : a user defined parameters which is used in output (write) formulas. 

@include structure

@begin Tessellator BasicTess
@end

@begin Primitive RationalTriangle2
@grid A,B,C,D,E,F as Bezier2Grid:<>
@grid Aw,Bw,Cw,Dw,Ew,Fw as Bezier2Grid:float
@use uvw
@define WW:1 (Aw*w*w+Bw*u*u+Cw*v*v+Dw*2*u*w+Ew*2*u*v+Fw*2*v*w)
@define W:1 1/WW
@write <> A*w*w*Aw*W+B*u*u*Bw*W+C*v*v*Cw*W+D*2*u*w*Dw*W+E*2*u*v*Ew*W+F*2*v*w*Fw*W
@end

@begin Primitive Triangle2
@grid A,B,C,D,E,F as Bezier2Grid:<>
@use uvw
@write <> A*w*w+B*u*u+C*v*v+D*2*u*w+E*2*u*v+F*2*v*w
@end


@begin Primitive Triangle3
@grid A,B,C,AB,BA,BC,CB,CA,AC,ACB as Bezier3Grid:<>
@use uvw
@write <> A*w*w*w+B*u*u*u+C*v*v*v+AB*3*w*w*u+BA*3*w*u*u+AC*3*w*w*v+CA*3*w*v*v+BC*3*u*u*v+CB*3*u*v*v+6*ACB*u*v*w
@end


@begin Primitive Triangle
@grid A,B,C as TriangleGrid:<>
@use uvw
@write <> A*w+B*u+C*v 
@end


@begin Primitive Constant
@grid A as ConstantGrid:<>
@use uvw
@write <> A
@end

@begin Transforms BasicP
@use modelview
@use projection
@use P0
@write position projection*modelview*P0
@end

@begin Transforms BasicN
@use vectorsModelview
@use N0
@write normal vectorsModelview*N0  
@end

@begin Material BasicMat
@param diffColor,ambColor as Mat01
@write color diffColor 
@end


@begin Material TexturedMat
@use texture0
@use texCoord0
@write color texture0%texCoord0
@end

@begin Material TextCoord
@use texture0
@use texCoord0
@write color texCoord0
@end

@begin LightStep DrawTexture
@use texture0
@use texCoord0
@write fColor texture0%texCoord0
@end

@begin LightStep DrawTextCoord
@use texCoord0
@write fColor texCoord0
@end

@begin Material BlackMat
@write color 0,0,0,1
@end

@begin LightStep BasicLSPN
@param intensity,lPosition as PLight01
@use normal 
@use position
@use color
@define tmp1:3 lPosition-position
@define tmp2:1 #(tmp1?tmp1)
@define tmp3:3 (normal?tmp1)/tmp2 
@write fColor color*intensity*tmp3
@end

@begin LightStep DrawNormals
@use normal 
@write fColor normal
@end

@begin LightStep DrawDus
@use duVector  
@write fColor duVector
@end

@begin LightStep DrawDvs
@use dvVector  
@write fColor dvVector
@end

@begin LightStep VectorsLight
@use normal 
@use duVector 
@use dvVector
@define tmp1:3 (0,1,1)
@write fColor (duVector?tmp1),(dvVector?tmp1),(normal?tmp1),1
@end

@begin LightStep BasicColor
@use color 
@write fColor color
@end

@begin LightStep BasicTest
@use color 
@write fColor color
@end

@begin LightStep BasicYellowColor
@use color 
@define yellow:3 (1,1,0)
@write fColor color*yellow
@end

@begin LightStep BasicGrayAndBright
@use color 
@define bright:3 0.4,0.4,0.4
@define grayscale:4 0.3,0.5,0.2,0
@define gray:1 (color?grayscale)
@define gray3:3 gray
@write fColor0 gray3
@write fColor1 color+bright
@end


@begin LightStep ReddishGrayAndBright
@use color 
@define bright:3 0.4,0.4,0.4
@define grayscale:4 0.3,0.5,0.2,0
@define gray:1 (color?grayscale)
@define gray3:3 gray
@define red1:4 1,0.2,0.2,1
@write fColor0 red1+color
@write fColor1 color*red1
@end

@begin LightStep NormalAndPosition
@use position
@use normal 
@write fColor0 normal
@write fColor1 position
@end

@begin LightStep NormalAndColor
@use color
@use normal 
@write fColor0 normal
@write fColor1 color
@end

@begin LightStep BumpMaps
@use color
@use normal 
@use position 
@define half:3 0.5,0.5,1
@define sum:3 0.5,0.5,0
@write fColor0 normal*half+sum
@write fColor1 color
@write fColor2 (0-position.z)*10
@end

@begin Material BumpMappedMat
@use normal
@use duVector
@use dvVector
@use texture0
@use texture1
@use texCoord0
@define bumpMap:3 texture1%texCoord0 
@write color texture0%texCoord0
@write normal ((1-2*bumpMap.x)*duVector)+((1-2*bumpMap.y)*dvVector)+(bumpMap.z*normal)
@end

@begin LightStep BasicLSPN2
@param intensity,lPosition as PLight01
@use normal 
@use position
@use color
@define tmp1:3 lPosition-position
@define tmp2:1 #(tmp1?tmp1)
@define tmp3:3 0.6+0.4*((normal?tmp1)/tmp2) 
@write fColor color*intensity*tmp3
//@write fColor color
@end

@begin Material ImprovedBumpMappedMat
@param intensity,lPosition as PLight01
@use position
@use normal
@use duVector
@use dvVector
@use texture0
@use texture1
@use texCoord0
@define bumpMaptmp1:3 lPosition-position
@define bumpMaptmp2:1 #(bumpMaptmp1?bumpMaptmp1)
@define bumpMaptmp3:1 #(normal?normal)
@define bumpMaptmp4:1 bumpMaptmp2*bumpMaptmp3
@define bumpMaptmp5:1 ((normal?bumpMaptmp1)/bumpMaptmp4)
@define bumpMaptmp6:1 bumpMaptmp5*0.5+0.5
@define bumpMaptmp7:1 1.1-bumpMaptmp6
@define bumpMaptmp8:1 bumpMaptmp7*bumpMaptmp7
@define improveFactor:1 1-bumpMaptmp8
@define bumpMap:3 (texture1%texCoord0)
@define bumpMapImprovedX:1 (improveFactor-2*improveFactor*bumpMap.x)
@define bumpMapImprovedY:1 (improveFactor-2*improveFactor*bumpMap.y)
@define bumpMapImprovedZ:1 bumpMap.z*improveFactor+1-improveFactor
@define bumpMapImproved:3 bumpMapImprovedX,bumpMapImprovedY,bumpMapImprovedZ
//@write color bumpMapImproved
@write color texture0%texCoord0
@write normal (bumpMapImproved.x*duVector)+(bumpMapImproved.y*dvVector)+(bumpMapImproved.z*normal)
@end


@begin Material ParallaxMappedMat
@use normal
@use duVector
@use dvVector
@use texture0
@use texture1
@use texture2
@use texCoord0
@define tmp2DU:1 #(duVector?duVector)
@define tmp2DV:1 #(dvVector?dvVector) 
@define xdu:1 duVector.x/tmp2DU
@define xdv:1 dvVector.x/tmp2DV
@define ydu:1 duVector.y/tmp2DU
@define ydv:1 dvVector.y/tmp2DV
@define delta:1 xdu*ydv-xdv*ydu
@define deltaRec:1 (delta*delta)
@define delta2:1 delta/deltaRec
@define kValue:3  (texture2%texCoord0)*normal*(-1)
@define kValueX:1  0.02*kValue.x
@define kValueY:1  0.02*kValue.y
@define DeltaU:1  delta2*(kValueX*ydu-kValueY*xdv)
@define DeltaV:1  delta2*(kValueY*ydv-kValueX*ydu)
@define texC:2  texCoord0-(DeltaU,DeltaV)
@define bumpMap:3 texture1%texC 
@write color texture0%texC
//@write color (DeltaU*0.5+0.5),(DeltaV*0.5+0.5),0,1
//@write color texture2%texCoord0
@write normal ((1-2*bumpMap.x)*duVector)+((1-2*bumpMap.y)*dvVector)+(bumpMap.z*normal)
@end

@begin LightStep DrawData
@use color 
@write fColor color
@end
