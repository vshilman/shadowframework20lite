
Test_sv1Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[CLASS_DECLARATION] -------> public class Test_sv1Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int vertexColorAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  triangleVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  triangleVertexColorBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  squareVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  squareVertexColorBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader1.fs", "shaders/shader1.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexColorAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexColor")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexColorAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[METHOD_DECLARATION] ------->  public void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, triangleVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, triangleVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexPositionBuffer[2]    = 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, triangleVertexColorBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, triangleVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  colors   =
[ARRAY_CONTENT_DECLARTION] -------> 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, colors.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(colors), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexColorBuffer[2]    = 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, squareVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, squareVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices2   =
[ARRAY_CONTENT_DECLARTION] -------> 1.0f, 1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, -1.0f, 0.0f, -1.0f, -1.0f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexPositionBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, squareVertexColorBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, squareVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  colors2   = new  float[16]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 4 ; i++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  c   = i << 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c + 1]    = 0.75f
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c + 2]    = 0.8f
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c + 3]    = 1
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, colors2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(colors2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexColorBuffer[2]    = 4
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1.5f, 0, 0, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, triangleVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, triangleVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, triangleVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexColorAttribute, triangleVertexColorBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLES, 0, triangleVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1.5f, 0, 0, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, squareVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, squareVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, squareVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexColorAttribute, squareVertexColorBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, squareVertexPositionBuffer[2])

Test_sv2Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[CLASS_DECLARATION] -------> public class Test_sv2Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int vertexColorAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexColorBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  baseVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  baseVertexColorBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngle   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader1.fs", "shaders/shader1.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexColorAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexColor")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexColorAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[METHOD_DECLARATION] ------->  public void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[2]    = 6
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexColorBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  colors   =
[ARRAY_CONTENT_DECLARTION] -------> 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, colors.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(colors), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexColorBuffer[2]    = 6
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, baseVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, baseVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices2   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexPositionBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, baseVertexColorBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, baseVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  colors2   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, colors2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(colors2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexColorBuffer[2]    = 4
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cx, sx * sx, -cx * sx, 0, 0, cx, sx, 0, sx, -cx * sx, cx * cx, 0, 0, 0, -8, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, pyramidVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexColorAttribute, pyramidVertexColorBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_FAN, 0, pyramidVertexPositionBuffer[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, baseVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, baseVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, baseVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexColorAttribute, baseVertexColorBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, baseVertexPositionBuffer[2])
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngle   + = 1.57 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow

Test_sv3Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.io.File
[LIBRARY_DECLARATION] -------> import java.io.IOException
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO
[CLASS_DECLARATION] -------> public class Test_sv3Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  texture1   = new  int[1]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngle   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.glGetAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.glGetUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  cubeVertexIndices   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(cubeVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] ------->  public void  initTexture ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenTextures(1, texture1, 0)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = TextureIO.newTextureData(new , File("images/crate.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, texture1[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, 0)
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cx * cx, cx * (sx * sx + sx), sx * sx - cx * cx * sx, 0, -cx * sx, cx * cx - sx * sx * sx, cx * (sx * sx + sx), 0, sx, -cx * sx, cx * cx, 0, 0, 0, -8, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, texture1[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, cubeVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngle   + = 1.57 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow

Test_sv4Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.io.File
[LIBRARY_DECLARATION] -------> import java.io.IOException
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO
[CLASS_DECLARATION] -------> public class Test_sv4Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  textures   = new  int[3]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[6]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int  filter   = 0
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.glGetAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.glGetUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  cubeVertexIndices   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(cubeVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] ------->  public void  initTexture ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenTextures(3, textures, 0)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = TextureIO.newTextureData(new , File("images/crate.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, 0)
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, 0, 0, zoom, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[filter])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, cubeVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2 != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 70 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> filter    = filter == 2 ? 0 : (filter + 1)
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)

Test_sv5Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.io.File
[LIBRARY_DECLARATION] -------> import java.io.IOException
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO
[CLASS_DECLARATION] -------> public class Test_sv5Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  textures   = new  int[3]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[6]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int  wrapper   = 0
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.glGetAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.glGetUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, -1.0f, -1.0f, -1.0f, 2.0f, -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, 2.0f, 2.0f, -1.0f, 2.0f, -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, -1.0f, -1.0f, -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  cubeVertexIndices   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(cubeVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] ------->  public void  initTexture ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenTextures(3, textures, 0)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = TextureIO.newTextureData(new , File("images/roof.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, 0)
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, 0, 0, zoom, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[wrapper])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, cubeVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2 != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 87 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> wrapper    = wrapper == 2 ? 0 : (wrapper + 1)
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)

Test_sv6Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.io.File
[LIBRARY_DECLARATION] -------> import java.io.IOException
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO
[CLASS_DECLARATION] -------> public class Test_sv6Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform
[ATTRIBUTE_DECLARATION] -------> private int lightingDirectionUniform
[ATTRIBUTE_DECLARATION] -------> private int directionalColorUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  textures   = new  int[1]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[6]
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader3.fs", "shaders/shader3.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.glGetAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.glGetUniformLocation(shaderProgram, "uSampler")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.glGetUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lightingDirectionUniform    = gl.glGetUniformLocation(shaderProgram, "uLightingDirection")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> directionalColorUniform    = gl.glGetUniformLocation(shaderProgram, "uDirectionalColor")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix3fv(nMatrixUniform, 9, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(ambientColorUniform, 0.1f, 0.1f, 0.1f)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  lightingDirectionv   =
[ARRAY_CONTENT_DECLARTION] -------> 0.57735026918962576450914878050196f, 0.57735026918962576450914878050196f, 0.57735026918962576450914878050196f
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> FloatBuffer  lightingDirection   = BufferUtil.newFloatBuffer(lightingDirectionv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3fv(lightingDirectionUniform, lightingDirectionv.length, lightingDirection)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(directionalColorUniform, 0.7f, 0.7f, 0.7f)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, -1.0f, -1.0f, -1.0f, 2.0f, -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, 2.0f, 2.0f, -1.0f, 2.0f, -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f, -1.0f, -1.0f, -1.0f, -1.0f, 2.0f, -1.0f, 2.0f, 2.0f, -1.0f, 2.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  cubeVertexIndices   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(cubeVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] ------->  public void  initTexture ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenTextures(1, textures, 0)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = TextureIO.newTextureData(new , File("images/muro.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex.getWidth(), tex.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, 0)
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, 0, 0, zoom, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normalMatrixv   = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, cubeVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, cubeVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2 != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)

Test_sv7Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[CLASS_DECLARATION] -------> public class Test_sv7Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingColorUniform
[ATTRIBUTE_DECLARATION] -------> private int shaderUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int  shaderChoice   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  sphereVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  sphereVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  sphereVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[6]
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader4.fs", "shaders/shader4.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.glGetUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingColorUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderUniform    = gl.glGetUniformLocation(shaderProgram, "uShader")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix3fv(nMatrixUniform, 9, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(ambientColorUniform, 0.1f, 0.1f, 0.1f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingLocationUniform, 0, 0, -5.1f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingColorUniform, 0.7f, 0.7f, 0.7f)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  latitudeBands   = 15
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  longitudeBands   = 15
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  radius   = 2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   = new  float[3 * (latitudeBands + 1) * (longitudeBands + 1)]
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals   = new  float[3 * (latitudeBands + 1) * (longitudeBands + 1)]
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  sphereVertexIndices   = new  int[6 * latitudeBands * longitudeBands]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   <= latitudeBands ; i++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  theta   = (float) (i * Math.PI / latitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sinTheta   = (float) Math.sin(theta)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cosTheta   = (float) Math.cos(theta)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   <= longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  phi   = (float) (j * 2 * Math.PI / longitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sinPhi   = (float) Math.sin(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cosPhi   = (float) Math.cos(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  x   = cosPhi * sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  y   = cosTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  z   = sinPhi * sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  index   = 3 * (j + i * (longitudeBands + 1))
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index]    = radius * x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index + 1]    = radius * y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index + 2]    = radius * z
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index]    = x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index + 1]    = y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index + 2]    = z
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < latitudeBands ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  first   = (i * (longitudeBands + 1)) + j
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  second   = first + longitudeBands + 1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  index   = 6 * (j + i * longitudeBands)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index]    = first
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 1]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 2]    = first + 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 3]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 4]    = second + 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 5]    = first + 1
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, sphereVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[2]    = vertices.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, sphereVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[2]    = normals.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, sphereVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, sphereVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(sphereVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[2]    = sphereVertexIndices.length
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(shaderUniform, shaderChoice)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, 0, 0, zoom, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normalMatrixv   = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, sphereVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, sphereVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, sphereVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2 != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 83 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderChoice    = shaderChoice == 1 ? 0 : (shaderChoice + 1)
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)

Test_sv8Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util.ObjModel
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[CLASS_DECLARATION] -------> public class Test_sv8Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingSpecularColorUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingDiffuseColorUniform
[ATTRIBUTE_DECLARATION] -------> private int materialShininessUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  teapotVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  teapotVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  teapotVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[6]
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader5.fs", "shaders/shader5.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.glGetUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingSpecularColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingDiffuseColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    = gl.glGetUniformLocation(shaderProgram, "uMaterialShininess")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix3fv(nMatrixUniform, 9, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(ambientColorUniform, 0.1f, 0.1f, 0.1f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingLocationUniform, -1, 0, -5.1f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingDiffuseColorUniform, 0.7f, 0.7f, 0.7f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingSpecularColorUniform, 0.7f, 0.7f, 0.7f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1f(materialShininessUniform, 10)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ObjModel  teapot   = Util.loadObj("models/teapot.obj")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, teapotVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, teapotVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, teapot.vertexPositions.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(teapot.vertexPositions), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexPositionBuffer[2]    = teapot.vertexPositions.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, teapotVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, teapotVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, teapot.vertexNormals.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(teapot.vertexNormals), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexNormalBuffer[2]    = teapot.vertexNormals.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, teapotVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, teapot.indices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(teapot.indices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexIndexBuffer[2]    = teapot.indices.length
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, 0, 0, zoom, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normalMatrixv   = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, teapotVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, teapotVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, teapotVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, teapotVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, teapotVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2 != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)

Test_sv9Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.awt.event.MouseEvent
[LIBRARY_DECLARATION] -------> import java.io.File
[LIBRARY_DECLARATION] -------> import java.io.IOException
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO
[CLASS_DECLARATION] -------> public class Test_sv9Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingSpecularColorUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingDiffuseColorUniform
[ATTRIBUTE_DECLARATION] -------> private int materialShininessUniform
[ATTRIBUTE_DECLARATION] -------> private int alphaUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  sphereVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  sphereVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  sphereVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  sphereVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  textures   = new  int[2]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[6]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int  lastMouseX   = -1
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int  lastMouseY   = -1
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float[]  rotationMatrix   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader6.fs", "shaders/shader6.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.glGetAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.glGetUniformLocation(shaderProgram, "uSampler")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.glGetUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingSpecularColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingDiffuseColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    = gl.glGetUniformLocation(shaderProgram, "uMaterialShininess")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> alphaUniform    = gl.glGetUniformLocation(shaderProgram, "uAlpha")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix3fv(nMatrixUniform, 9, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(ambientColorUniform, 0.1f, 0.1f, 0.1f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingLocationUniform, -10, 0, 5f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingDiffuseColorUniform, 0.4f, 0.4f, 0.4f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingSpecularColorUniform, 0.5f, 0.5f, 0.5f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1f(materialShininessUniform, 50)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  latitudeBands   = 30
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  longitudeBands   = 30
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  radius   = 2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices   = new  float[3 * (latitudeBands + 1) * (longitudeBands + 1)]
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals   = new  float[3 * (latitudeBands + 1) * (longitudeBands + 1)]
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords   = new  float[2 * (latitudeBands + 1) * (longitudeBands + 1)]
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  sphereVertexIndices   = new  int[6 * latitudeBands * longitudeBands]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   <= latitudeBands ; i++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  theta   = (float) (i * Math.PI / latitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sinTheta   = (float) Math.sin(theta)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cosTheta   = (float) Math.cos(theta)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   <= longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  phi   = (float) (j * 2 * Math.PI / longitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sinPhi   = (float) Math.sin(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cosPhi   = (float) Math.cos(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  x   = cosPhi * sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  y   = cosTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  z   = sinPhi * sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  u   = 1 - ((float) j / longitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  v   = 1 - ((float) i / latitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  index   = 3 * (j + i * (longitudeBands + 1))
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index]    = radius * x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index + 1]    = radius * y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index + 2]    = radius * z
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index]    = x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index + 1]    = y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index + 2]    = z
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> index    = 2 * (j + i * (longitudeBands + 1))
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoords[index]    = u
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoords[index + 1]    = v
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < latitudeBands ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  first   = (i * (longitudeBands + 1)) + j
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  second   = first + longitudeBands + 1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  index   = 6 * (j + i * longitudeBands)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index]    = first
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 1]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 2]    = first + 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 3]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 4]    = second + 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index + 5]    = first + 1
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, sphereVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[2]    = vertices.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, sphereVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[2]    = normals.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, sphereVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexTextureCoordBuffer[2]    = textureCoords.length / 2
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, sphereVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, sphereVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(sphereVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[2]    = sphereVertexIndices.length
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices2   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords2   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 10.0f, 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals2   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[2]    = 4
[METHOD_DECLARATION] ------->  public void  initTexture ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenTextures(2, textures, 0)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex1
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1    = TextureIO.newTextureData(new , File("images/bubble.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex1.getWidth(), tex1.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex1.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex2
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2    = TextureIO.newTextureData(new , File("images/grass.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex2.getWidth(), tex2.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex2.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, 0)
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_BLEND)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 10, 0, 0, 0, 0, 10, 0, 0, 0, 0, 10, 0, 0, 0, zoom, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normalMatrixv   = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, greenVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, greenVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, greenVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1f(alphaUniform, 1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, greenVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, zoom, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = Util.multiplyMatrix(rotationMatrix, mvMatrixv)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, sphereVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, sphereVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, sphereVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, sphereVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1f(alphaUniform, 0.8f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, sphereVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2 != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)
[METHOD_DECLARATION] ------->  public void  mousePressed ( MouseEvent  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseX    = e.getX()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseY    = e.getY()
[METHOD_DECLARATION] ------->  public void  mouseDragged ( MouseEvent  e )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  deltaX   = e.getX() - lastMouseX
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  deltaY   = e.getY() - lastMouseY
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> double  rAnglex   = deltaY * 0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> double  rAngley   = deltaX * 0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  newRotationMatrix   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, 0, 0, 0, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rotationMatrix    = Util.multiplyMatrix(rotationMatrix, newRotationMatrix)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseX    = e.getX()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseY    = e.getY()

Test_va1Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.io.File
[LIBRARY_DECLARATION] -------> import java.io.IOException
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO
[CLASS_DECLARATION] -------> public class Test_va1Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  doorVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  doorVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  textures   = new  int[4]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[6]
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.glGetAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.glGetUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices1   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices1.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices1), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[2]    = 6
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords1   =
[ARRAY_CONTENT_DECLARTION] -------> 3.0f, 0.0f, 0.0f, 6.0f, 6.0f, 6.0f, 0.0f, 6.0f, 6.0f, 6.0f, 0.0f, 6.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords1.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords1), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[2]    = 6
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices2   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 16
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords2   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 0.0f, 0.0f, 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 16
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  cubeVertexIndices   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(cubeVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices3   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices3.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices3), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords3   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 10.0f, 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords3.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords3), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, doorVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices4   =
[ARRAY_CONTENT_DECLARTION] -------> -0.2f, -1.0f, 1.001f, 0.2f, -1.0f, 1.001f, -0.2f, 0.0f, 1.001f, 0.2f, 0.0f, 1.001f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices4.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices4), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, doorVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords4   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords4.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords4), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[2]    = 4
[METHOD_DECLARATION] ------->  public void  initTexture ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenTextures(4, textures, 0)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex1
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1    = TextureIO.newTextureData(new , File("images/muro.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex1.getWidth(), tex1.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex1.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex2
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2    = TextureIO.newTextureData(new , File("images/roof.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex2.getWidth(), tex2.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex2.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex3
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3    = TextureIO.newTextureData(new , File("images/grass.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex3.getWidth(), tex3.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex3.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex4
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4    = TextureIO.newTextureData(new , File("images/door.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex4.getWidth(), tex4.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex4.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, 0)
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.71f, 0.91f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, 0, -cx, zoom - sx, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, cubeVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, doorVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, doorVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, doorVertexPositionBuffer[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDisable(GL2.GL_CULL_FACE)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv2   = mvMatrixv.clone()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[0]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[1]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[2]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[8]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[9]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[10]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, greenVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, greenVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, greenVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = mvMatrixv2
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[13]   + = 2 * cx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[14]   + = 2 * sx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, pyramidVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, pyramidVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_FAN, 0, pyramidVertexPositionBuffer[2])
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2 != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2 * elapsed * 0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2 * elapsed * 0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)

Test_va2Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent
[LIBRARY_DECLARATION] -------> import java.io.File
[LIBRARY_DECLARATION] -------> import java.io.IOException
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util.ObjModel
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO
[CLASS_DECLARATION] -------> public class Test_va2Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingSpecularColorUniform
[ATTRIBUTE_DECLARATION] -------> private int pointLightingDiffuseColorUniform
[ATTRIBUTE_DECLARATION] -------> private int materialShininessUniform
[ATTRIBUTE_DECLARATION] -------> private int alphaUniform
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  doorVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  doorVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  doorVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  greenVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  pyramidVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  cubeVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  tractorVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  tractorVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  tractorVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  tractorVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  seagulVertexPositionBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  seagulVertexNormalBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  seagulVertexTextureCoordBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  seagulVertexIndexBuffer   = new  int[3]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[]  textures   = new  int[6]
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long  lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[]  commands   = new  boolean[8]
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  seagulAngle   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  tractorx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  pitch   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  yaw   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  xPos   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  yStart   = -1.5f
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  yPos   = yStart
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  zPos   = 10
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  speed   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  lspeed   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  pitchRate   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float  yawRate   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double  joggingAngle   = 0
[METHOD_DECLARATION] ------->  public void  initShaders ( GL2  gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int  shaderProgram   = Util.getShaderProgram(gl, "shaders/shader6.fs", "shaders/shader6.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.glGetAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.glGetAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.glGetUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.glGetUniformLocation(shaderProgram, "uSampler")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.glGetUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingSpecularColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    = gl.glGetUniformLocation(shaderProgram, "uPointLightingDiffuseColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    = gl.glGetUniformLocation(shaderProgram, "uMaterialShininess")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> alphaUniform    = gl.glGetUniformLocation(shaderProgram, "uAlpha")
[METHOD_DECLARATION] ------->  private void  setMatrixUniforms ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(pMatrixUniform, 16, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix4fv(mvMatrixUniform, 16, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniformMatrix3fv(nMatrixUniform, 9, false, normalMatrix)
[METHOD_DECLARATION] ------->  public void  initBuffers ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices1   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices1.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices1), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[2]    = 12
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals1   =
[ARRAY_CONTENT_DECLARTION] -------> -0.89442719099991587856366946749251f, 0.44721359549995793928183473374626f, 0.0f, -0.89442719099991587856366946749251f, 0.44721359549995793928183473374626f, 0.0f, -0.89442719099991587856366946749251f, 0.44721359549995793928183473374626f, 0.0f, 0.0f, 0.44721359549995793928183473374626f, -0.89442719099991587856366946749251f, 0.0f, 0.44721359549995793928183473374626f, -0.89442719099991587856366946749251f, 0.0f, 0.44721359549995793928183473374626f, -0.89442719099991587856366946749251f, 0.0f, 0.44721359549995793928183473374626f, 0.89442719099991587856366946749251f, 0.0f, 0.44721359549995793928183473374626f, 0.89442719099991587856366946749251f, 0.0f, 0.44721359549995793928183473374626f, 0.89442719099991587856366946749251f, 0.89442719099991587856366946749251f, 0.44721359549995793928183473374626f, 0.0f, 0.89442719099991587856366946749251f, 0.44721359549995793928183473374626f, 0.0f, 0.89442719099991587856366946749251f, 0.44721359549995793928183473374626f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals1.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals1), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexNormalBuffer[2]    = 12
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords1   =
[ARRAY_CONTENT_DECLARTION] -------> 3.0f, 0.0f, 0.0f, 6.0f, 6.0f, 6.0f, 3.0f, 0.0f, 0.0f, 6.0f, 6.0f, 6.0f, 3.0f, 0.0f, 6.0f, 6.0f, 0.0f, 6.0f, 3.0f, 0.0f, 0.0f, 6.0f, 6.0f, 6.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords1.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords1), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[2]    = 12
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, pyramidVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, pyramidVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  pyramidVertexIndices   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 1, 2, 3, 5, 4, 6, 7, 8, 9, 10, 11
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, pyramidVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(pyramidVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexIndexBuffer[2]    = 12
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices2   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 16
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals2   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[2]    = 16
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords2   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f, 0.0f, 0.0f, 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f, 0.0f, 10.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords2.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords2), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 16
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, cubeVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int[]  cubeVertexIndices   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(cubeVertexIndices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 24
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices3   =
[ARRAY_CONTENT_DECLARTION] -------> -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices3.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices3), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals3   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals3.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals3), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, greenVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords3   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 10.0f, 0.0f, 0.0f, 10.0f, 0.0f, 10.0f, 10.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords3.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords3), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, doorVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  vertices4   =
[ARRAY_CONTENT_DECLARTION] -------> -0.2f, -1.0f, 1.001f, 0.2f, -1.0f, 1.001f, -0.2f, 0.0f, 1.001f, 0.2f, 0.0f, 1.001f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, vertices4.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(vertices4), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, doorVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normals4   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, normals4.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(normals4), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexNormalBuffer[2]    = 4
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, doorVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  textureCoords4   =
[ARRAY_CONTENT_DECLARTION] -------> 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, textureCoords4.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(textureCoords4), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[2]    = 4
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ObjModel  tractor   = Util.loadObj("models/tractor.obj")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, tractorVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, tractorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, tractor.vertexPositions.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(tractor.vertexPositions), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexPositionBuffer[2]    = tractor.vertexPositions.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, tractorVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, tractorVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, tractor.vertexNormals.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(tractor.vertexNormals), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexNormalBuffer[2]    = tractor.vertexNormals.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, tractorVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, tractorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, tractor.vertexTextureCoords.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(tractor.vertexTextureCoords), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexTextureCoordBuffer[2]    = tractor.vertexTextureCoords.length / 2
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, tractorVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, tractorVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, tractor.indices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(tractor.indices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexIndexBuffer[2]    = tractor.indices.length
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ObjModel  seagul   = Util.loadObj("models/seagul.obj")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, seagulVertexPositionBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, seagulVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, seagul.vertexPositions.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(seagul.vertexPositions), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexPositionBuffer[2]    = seagul.vertexPositions.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, seagulVertexNormalBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, seagulVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, seagul.vertexNormals.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(seagul.vertexNormals), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexNormalBuffer[2]    = seagul.vertexNormals.length / 3
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, seagulVertexTextureCoordBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, seagulVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ARRAY_BUFFER, seagul.vertexTextureCoords.length * BufferUtil.SIZEOF_FLOAT, BufferUtil.newFloatBuffer(seagul.vertexTextureCoords), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexTextureCoordBuffer[2]    = seagul.vertexTextureCoords.length / 2
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenBuffers(1, seagulVertexIndexBuffer, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, seagulVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBufferData(GL2.GL_ELEMENT_ARRAY_BUFFER, seagul.indices.length * BufferUtil.SIZEOF_INT, BufferUtil.newIntBuffer(seagul.indices), GL2.GL_STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexIndexBuffer[2]    = seagul.indices.length
[METHOD_DECLARATION] ------->  public void  initTexture ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenTextures(5, textures, 0)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex1
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1    = TextureIO.newTextureData(new , File("images/muro.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex1.getWidth(), tex1.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex1.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex2
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2    = TextureIO.newTextureData(new , File("images/roof.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex2.getWidth(), tex2.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex2.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex3
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3    = TextureIO.newTextureData(new , File("images/grass.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex3.getWidth(), tex3.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex3.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex4
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4    = TextureIO.newTextureData(new , File("images/door.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex4.getWidth(), tex4.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex4.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex5
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex5    = TextureIO.newTextureData(new , File("images/tractor.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex5    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[4])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex5.getWidth(), tex5.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex5.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> TextureData  tex6
[ISOLATED_KEYWORDS] -------> try
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex6    = TextureIO.newTextureData(new , File("images/seagul.gif"), false, null)
[CONSTRUCTOR_DECLARATION] ------->  catch   ( IOException  e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex6    = null
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[5])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexImage2D(GL2.GL_TEXTURE_2D, 0, GL2.GL_RGB, tex6.getWidth(), tex6.getHeight(), 0, GL2.GL_RGB, GL2.GL_UNSIGNED_BYTE, tex6.getBuffer())
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MAG_FILTER, GL2.GL_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_MIN_FILTER, GL2.GL_LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_S, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glTexParameteri(GL2.GL_TEXTURE_2D, GL2.GL_TEXTURE_WRAP_T, GL2.GL_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glGenerateMipmap(GL2.GL_TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, 0)
[METHOD_DECLARATION] ------->  public void  drawScene ( GL2  gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClearColor(0.0f, 0.71f, 0.91f, 1.0f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glCullFace(GL2.GL_BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[CONSTRUCTOR_DECLARATION] ------->  handleKeys (  )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glViewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cx   = (float) Math.cos(-pitch)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sx   = (float) Math.sin(-pitch)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cy   = (float) Math.cos(-yaw)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  sy   = (float) Math.sin(-yaw)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  pMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> 2.4142136573791504f, 0, 0, 0, 0, 2.4142136573791504f, 0, 0, 0, 0, -1.0020020008087158f, -1, 0, 0, -0.20020020008087158f, 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = BufferUtil.newFloatBuffer(pMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv   = new  float[]
[ARRAY_CONTENT_DECLARTION] -------> cy, sx * sy, -cx * sy, 0, 0, cx, sx, 0, sy, -cy * sx, cx * cy, 0, -cy * xPos - sy * zPos, -cx - sx * sy * xPos - cx * yPos + cy * sx * zPos, -sx + cx * sy * xPos - sx * yPos - cx * cy * zPos, 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  normalMatrixv   = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(ambientColorUniform, 0.1f, 0.1f, 0.1f)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  lightLoc   =
[ARRAY_CONTENT_DECLARTION] -------> 0, 4, 2, 1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  tlightLoc   = Util.multiplyMatrixVector(pMatrixv, Util.multiplyMatrixVector(mvMatrixv, lightLoc))
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingLocationUniform, tlightLoc[0], tlightLoc[1], tlightLoc[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingDiffuseColorUniform, 0.5f, 0.5f, 0.5f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform3f(pointLightingSpecularColorUniform, 0.5f, 0.5f, 0.5f)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1f(materialShininessUniform, 50)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1f(alphaUniform, 1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glFrontFace(GL2.GL_CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, cubeVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glActiveTexture(GL2.GL_TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, cubeVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, doorVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, doorVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, doorVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, doorVertexPositionBuffer[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDisable(GL2.GL_CULL_FACE)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[]  mvMatrixv2   = mvMatrixv.clone()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[0]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[1]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[2]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[8]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[9]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[10]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, greenVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, greenVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, greenVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, greenVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = mvMatrixv2.clone()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glEnable(GL2.GL_CULL_FACE)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[13]   + = 2 * cx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[14]   + = 2 * sx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, pyramidVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, pyramidVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, pyramidVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, pyramidVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, pyramidVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = mvMatrixv2.clone()
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 12 ; i++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[i]   * = 0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  xt   = -11 + tractorx
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  yt   = -1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  zt   = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[12]   + = cy * xt + sy * zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[13]   + = sx * sy * xt + cx * yt - cy * sx * zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[14]   + = -cx * sy * xt + sx * yt + cx * cy * zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, tractorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, tractorVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, tractorVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, tractorVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, tractorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, tractorVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[4])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, tractorVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, tractorVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = mvMatrixv2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  cs   = (float) Math.cos(seagulAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  ss   = (float) Math.sin(seagulAngle)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> xt    = -3 * cs - xPos
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yt    = 2 - yPos
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zt    = 4 * ss - zPos
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float  s   = 0.3f
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[0]    = cs * cy * s - s * ss * sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[1]    = cy * s * ss * sx + cs * s * sx * sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[2]    = -cx * cy * s * ss - cs * cx * s * sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[3]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[4]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[5]    = cx * s
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[6]    = s * sx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[7]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[8]    = cy * s * ss + cs * s * sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[9]    = -cs * cy * s * sx + s * ss * sx * sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[10]    = cs * cx * cy * s - cx * s * ss * sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[11]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[12]    = cy * xt + sy * zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[13]    = -cx + sx * sy * xt + cx * yt - cy * sx * zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[14]    = -sx - cx * sy * xt + sx * yt + cx * cy * zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv[15]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = BufferUtil.newFloatBuffer(mvMatrixv)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    = new  float[9]
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv[i + 3 * j]    = mvMatrixv[i + 4 * j]
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = BufferUtil.newFloatBuffer(normalMatrixv)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, seagulVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexPositionAttribute, seagulVertexPositionBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, seagulVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(vertexNormalAttribute, seagulVertexNormalBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ARRAY_BUFFER, seagulVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glVertexAttribPointer(textureCoordAttribute, seagulVertexTextureCoordBuffer[1], GL2.GL_FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindTexture(GL2.GL_TEXTURE_2D, textures[5])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glUniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glBindBuffer(GL2.GL_ELEMENT_ARRAY_BUFFER, seagulVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.glDrawElements(GL2.GL_TRIANGLES, seagulVertexIndexBuffer[2], GL2.GL_UNSIGNED_INT, 0)
[CONSTRUCTOR_DECLARATION] ------->  animate (  )
[METHOD_DECLARATION] ------->  private void  animate (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  timeNow   = System.currentTimeMillis()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime != 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long  elapsed   = timeNow - lastTime
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> boolean  move   = false
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( speed != 0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> xPos   - = Math.sin(yaw) * speed * elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zPos   - = Math.cos(yaw) * speed * elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> move    = true
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lspeed != 0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> xPos   + = Math.cos(yaw) * lspeed * elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zPos   - = Math.sin(yaw) * lspeed * elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> move    = true
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( move )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> joggingAngle   + = elapsed * 0.0104
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yPos    = (float) (Math.sin(joggingAngle) / 20 + yStart)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yaw   + = yawRate * elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitch   + = pitchRate * elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulAngle   + = 0.0008 * elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorx   + = 0.0008 * elapsed
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( tractorx > 22 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorx    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] ------->  private void  handleKeys (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = 0.003f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = -0.003f
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = 0.00174f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = -0.00174f
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = 0.00174f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = -0.00174f
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[6] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = 0.003f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[7] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = -0.003f
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = 0
[METHOD_DECLARATION] ------->  private void  setCommands ( KeyEvent  e, boolean  value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 87 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 83 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 68 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[6]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.getKeyCode() == 65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[7]    = value
[METHOD_DECLARATION] ------->  public void  keyPressed ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, true)
[METHOD_DECLARATION] ------->  public void  keyReleased ( KeyEvent  e )
[CALL, LINE_OF_CODE] -------> setCommands(e, false)
