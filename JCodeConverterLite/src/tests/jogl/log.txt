
Test_sv1Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[CLASS_DECLARATION] -------> public class Test_sv1Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int vertexColorAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] triangleVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] triangleVertexColorBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] squareVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] squareVertexColorBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader1.fs"  ,  "shaders  / shader1.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexColorAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexColor"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexColorAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[METHOD_DECLARATION] ------->  public void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  triangleVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  triangleVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = { 0.0f,1.0f,0.0f,-1.0f,-1.0f,0.0f,1.0f,-1.0f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexPositionBuffer  [ 2 ]  = 3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  triangleVertexColorBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  triangleVertexColorBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] colors   = { 1.0f,0.0f,0.0f,1.0f,0.0f,1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  colors.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  colors   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexColorBuffer  [ 1 ]  = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexColorBuffer  [ 2 ]  = 3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  squareVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  squareVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices2   = { 1.0f,1.0f,0.0f,-1.0f,1.0f,0.0f,1.0f,-1.0f,0.0f,-1.0f,-1.0f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexPositionBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  squareVertexColorBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  squareVertexColorBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] colors2   = new  float  [ 16 ] 
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int i   = 0 ; i   < 4 ; i   ++  )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2  [  c   ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2  [  c  +1 ]  = 0.75f
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2  [  c  +2 ]  = 0.8f
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2  [  c  +3 ]  = 1
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  colors2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  colors2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexColorBuffer  [ 1 ]  = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexColorBuffer  [ 2 ]  = 4
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,4 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  { 1,0,0,0,0,1,0,0,0,0,1,0,-1.5f,0,0,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  triangleVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  triangleVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  triangleVertexColorBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexColorAttribute  ,  triangleVertexColorBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLES, 0,  triangleVertexPositionBuffer  [ 2 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = new  float  [  ]  { 1,0,0,0,0,1,0,0,0,0,1,0,1.5f,0,0,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  squareVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  squareVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  squareVertexColorBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexColorAttribute  ,  squareVertexColorBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_STRIP, 0,  squareVertexPositionBuffer  [ 2 ] )

Test_sv2Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[CLASS_DECLARATION] -------> public class Test_sv2Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int vertexColorAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexColorBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] baseVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] baseVertexColorBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngle   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader1.fs"  ,  "shaders  / shader1.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexColorAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexColor"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexColorAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[METHOD_DECLARATION] ------->  public void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = { 0.0f,1.0f,0.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer  [ 2 ]  = 6
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexColorBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexColorBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] colors   = { 1.0f,0.0f,0.0f,1.0f,0.0f,1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,1.0f,0.0f,1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,1.0f,0.0f,1.0f,0.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  colors.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  colors   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexColorBuffer  [ 1 ]  = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexColorBuffer  [ 2 ]  = 6
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  baseVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  baseVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices2   = { -1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexPositionBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  baseVertexColorBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  baseVertexColorBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] colors2   = { 0.0f,1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,1.0f,0.0f,0.0f,1.0f,1.0f,0.0f,1.0f,0.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  colors2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  colors2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexColorBuffer  [ 1 ]  = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexColorBuffer  [ 2 ]  = 4
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAngle   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAngle   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cx  , sx  * sx  ,-cx* sx  ,0,0, cx  , sx  ,0, sx  ,-cx* sx  , cx  * cx  ,0,0,0,-8,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  pyramidVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexColorBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexColorAttribute  ,  pyramidVertexColorBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_FAN, 0,  pyramidVertexPositionBuffer  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  baseVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  baseVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  baseVertexColorBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexColorAttribute  ,  baseVertexColorBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_STRIP, 0,  baseVertexPositionBuffer  [ 2 ] )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngle   + = 1.57* elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  

Test_sv3Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.io.File  
[LIBRARY_DECLARATION] -------> import java.io.IOException  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO  
[CLASS_DECLARATION] -------> public class Test_sv3Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] texture1   = new  int  [ 1 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngle   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader2.fs"  ,  "shaders  / shader2.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aTextureCoord"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  textureCoordAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uSampler"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = { -1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords   = { 0.0f,0.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,1.0f,1.0f,1.0f,1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,0.0f,0.0f,0.0f,0.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] cubeVertexIndices   = { 0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23 }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  cubeVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 2 ]  = 36
[METHOD_DECLARATION] ------->  public void initTexture   ( GL2 gl   ) throws IOException  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenTextures ( 1,  texture1  , 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex   =   TextureIO.newTextureData   ( new  File   (  "images  / crate.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  texture1  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ NEAREST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ NEAREST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D, 0 )
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAngle   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAngle   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cx  * cx  , cx  * (  sx  * sx  + sx   ), sx  * sx  - cx  * cx  * sx  ,0,-cx* sx  , cx  * cx  - sx  * sx  * sx  , cx  * (  sx  * sx  + sx   ),0, sx  ,-cx* sx  , cx  * cx  ,0,0,0,-8,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  cubeVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  cubeVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  texture1  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  cubeVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngle   + = 1.57* elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  

Test_sv4Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.io.File  
[LIBRARY_DECLARATION] -------> import java.io.IOException  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO  
[CLASS_DECLARATION] -------> public class Test_sv4Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] textures   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 6 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int filter   = 0
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader2.fs"  ,  "shaders  / shader2.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aTextureCoord"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  textureCoordAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uSampler"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = { -1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords   = { 0.0f,0.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,1.0f,1.0f,1.0f,1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f,0.0f,0.0f,0.0f,0.0f,1.0f,0.0f,1.0f,1.0f,0.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] cubeVertexIndices   = { 0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23 }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  cubeVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 2 ]  = 36
[METHOD_DECLARATION] ------->  public void initTexture   ( GL2 gl   ) throws IOException  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenTextures ( 3,  textures  , 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex   =   TextureIO.newTextureData   ( new  File   (  "images  / crate.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ NEAREST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ NEAREST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D, 0 )
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,0,0, zoom  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  cubeVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  cubeVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [  filter   ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  cubeVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + =  speedx  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + =  speedy  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 1 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 2 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 3 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 4 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 5 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    =  timeNow  
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==90 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==38 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==40 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==37 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==39 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==70 )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )

Test_sv5Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.io.File  
[LIBRARY_DECLARATION] -------> import java.io.IOException  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO  
[CLASS_DECLARATION] -------> public class Test_sv5Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] textures   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 6 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int wrapper   = 0
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader2.fs"  ,  "shaders  / shader2.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aTextureCoord"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  textureCoordAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uSampler"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = { -1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords   = { -1.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,-1.0f,-1.0f,-1.0f,2.0f,-1.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,2.0f,2.0f,-1.0f,2.0f,-1.0f,-1.0f,2.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,-1.0f,-1.0f,-1.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] cubeVertexIndices   = { 0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23 }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  cubeVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 2 ]  = 36
[METHOD_DECLARATION] ------->  public void initTexture   ( GL2 gl   ) throws IOException  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenTextures ( 3,  textures  , 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex   =   TextureIO.newTextureData   ( new  File   (  "images  / roof.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ MIRRORED_REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ MIRRORED_REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ CLAMP_TO_EDGE )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ CLAMP_TO_EDGE )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D, 0 )
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,0,0, zoom  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  cubeVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  cubeVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [  wrapper   ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  cubeVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + =  speedx  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + =  speedy  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 1 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 2 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 3 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 4 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 5 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    =  timeNow  
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==90 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==38 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==40 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==37 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==39 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==87 )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )

Test_sv6Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.io.File  
[LIBRARY_DECLARATION] -------> import java.io.IOException  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO  
[CLASS_DECLARATION] -------> public class Test_sv6Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute   
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform   
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int lightingDirectionUniform   
[ATTRIBUTE_DECLARATION] -------> private int directionalColorUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] textures   = new  int  [ 1 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 6 ] 
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader3.fs"  ,  "shaders  / shader3.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexNormal"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexNormalAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aTextureCoord"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  textureCoordAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uNMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uSampler"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uAmbientColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lightingDirectionUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uLightingDirection"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> directionalColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uDirectionalColor"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix3fv (  nMatrixUniform  , 9,  false  ,  normalMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  ambientColorUniform  , 0.1f, 0.1f, 0.1f )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] lightingDirectionv   = new  float  [  ]  { 0.57735026918962576450914878050196f,0.57735026918962576450914878050196f,0.57735026918962576450914878050196f }
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> FloatBuffer lightingDirection   =   BufferUtil.newFloatBuffer   (  lightingDirectionv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3fv (  lightingDirectionUniform  ,  lightingDirectionv.length  ,  lightingDirection   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  directionalColorUniform  , 0.7f, 0.7f, 0.7f )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = { -1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexNormalBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals   = { 0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords   = { -1.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,-1.0f,-1.0f,-1.0f,2.0f,-1.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,2.0f,2.0f,-1.0f,2.0f,-1.0f,-1.0f,2.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f,-1.0f,-1.0f,-1.0f,-1.0f,2.0f,-1.0f,2.0f,2.0f,-1.0f,2.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] cubeVertexIndices   = { 0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23 }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  cubeVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 2 ]  = 36
[METHOD_DECLARATION] ------->  public void initTexture   ( GL2 gl   ) throws IOException  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenTextures ( 1,  textures  , 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex   =   TextureIO.newTextureData   ( new  File   (  "images  / muro.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex.getWidth   (  ),   tex.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D, 0 )
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,0,0, zoom  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normalMatrixv   =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  cubeVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  cubeVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  cubeVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  cubeVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + =  speedx  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + =  speedy  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 1 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 2 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 3 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 4 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 5 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    =  timeNow  
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==90 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==38 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==40 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==37 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==39 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )

Test_sv7Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[CLASS_DECLARATION] -------> public class Test_sv7Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int shaderUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int shaderChoice   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] sphereVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] sphereVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] sphereVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 6 ] 
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader4.fs"  ,  "shaders  / shader4.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexNormal"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexNormalAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uNMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uAmbientColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingLocation"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uShader"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix3fv (  nMatrixUniform  , 9,  false  ,  normalMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  ambientColorUniform  , 0.1f, 0.1f, 0.1f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingLocationUniform  , 0, 0, -5.1f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingColorUniform  , 0.7f, 0.7f, 0.7f )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int latitudeBands   = 15
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int longitudeBands   = 15
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int radius   = 2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = new  float  [ 3* (  latitudeBands  +1 )* (  longitudeBands  +1 ) ] 
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals   = new  float  [ 3* (  latitudeBands  +1 )* (  longitudeBands  +1 ) ] 
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] sphereVertexIndices   = new  short  [ 6* latitudeBands  * longitudeBands   ] 
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int i   = 0 ; i   <=  latitudeBands   ; i   ++  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sinTheta   = ( float )  Math.sin   (  theta   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cosTheta   = ( float )  Math.cos   (  theta   )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int j   = 0 ; j   <=  longitudeBands   ; j   ++  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sinPhi   = ( float )  Math.sin   (  phi   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cosPhi   = ( float )  Math.cos   (  phi   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float x   =  cosPhi  * sinTheta  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float y   =  cosTheta  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float z   =  sinPhi  * sinTheta  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int index   = 3* (  j  + i  * (  longitudeBands  +1 ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices  [  index   ]  =  radius  * x  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices  [  index  +1 ]  =  radius  * y  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices  [  index  +2 ]  =  radius  * z  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals  [  index   ]  =  x  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals  [  index  +1 ]  =  y  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals  [  index  +2 ]  =  z  
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int i   = 0 ; i   <  latitudeBands   ; i   ++  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  sphereVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer  [ 2 ]  =  vertices.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  sphereVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer  [ 2 ]  =  normals.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  sphereVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  sphereVertexIndexBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  sphereVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  sphereVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer  [ 2 ]  =  sphereVertexIndices.length  
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  shaderUniform  ,  shaderChoice   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,0,0, zoom  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normalMatrixv   =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  sphereVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  sphereVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  sphereVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  sphereVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + =  speedx  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + =  speedy  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 1 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 2 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 3 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 4 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 5 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    =  timeNow  
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==90 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==38 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==40 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==37 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==39 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==83 )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )

Test_sv8Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util.ObjModel  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[CLASS_DECLARATION] -------> public class Test_sv8Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingSpecularColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingDiffuseColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int materialShininessUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] teapotVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] teapotVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] teapotVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 6 ] 
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader5.fs"  ,  "shaders  / shader5.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexNormal"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexNormalAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uNMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uAmbientColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingLocation"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingSpecularColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingDiffuseColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMaterialShininess"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix3fv (  nMatrixUniform  , 9,  false  ,  normalMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  ambientColorUniform  , 0.1f, 0.1f, 0.1f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingLocationUniform  , -1, 0, -5.1f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingDiffuseColorUniform  , 0.7f, 0.7f, 0.7f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingSpecularColorUniform  , 0.7f, 0.7f, 0.7f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1f (  materialShininessUniform  , 10 )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ObjModel teapot   =   Util.loadObj   (  "models  / teapot.obj"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  teapotVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  teapotVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  teapot.vertexPositions.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  teapot.vertexPositions   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexPositionBuffer  [ 2 ]  =  teapot.vertexPositions.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  teapotVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  teapotVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  teapot.vertexNormals.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  teapot.vertexNormals   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexNormalBuffer  [ 2 ]  =  teapot.vertexNormals.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  teapotVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  teapotVertexIndexBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  teapot.indices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  teapot.indices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexIndexBuffer  [ 2 ]  =  teapot.indices.length  
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,0,0, zoom  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normalMatrixv   =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  teapotVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  teapotVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  teapotVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  teapotVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  teapotVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  teapotVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + =  speedx  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + =  speedy  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 1 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 2 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 3 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 4 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 5 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    =  timeNow  
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==90 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==38 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==40 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==37 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==39 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )

Test_sv9Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.awt.event.MouseEvent  
[LIBRARY_DECLARATION] -------> import java.io.File  
[LIBRARY_DECLARATION] -------> import java.io.IOException  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO  
[CLASS_DECLARATION] -------> public class Test_sv9Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute   
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform   
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingSpecularColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingDiffuseColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int materialShininessUniform   
[ATTRIBUTE_DECLARATION] -------> private int alphaUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] sphereVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] sphereVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] sphereVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] sphereVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] textures   = new  int  [ 2 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 6 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int lastMouseX   = -1
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int lastMouseY   = -1
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float[] rotationMatrix   = new  float  [  ]  { 1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1 }
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader6.fs"  ,  "shaders  / shader6.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexNormal"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexNormalAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aTextureCoord"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  textureCoordAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uNMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uSampler"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uAmbientColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingLocation"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingSpecularColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingDiffuseColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMaterialShininess"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> alphaUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uAlpha"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix3fv (  nMatrixUniform  , 9,  false  ,  normalMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  ambientColorUniform  , 0.1f, 0.1f, 0.1f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingLocationUniform  , -10, 0, 5f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingDiffuseColorUniform  , 0.4f, 0.4f, 0.4f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingSpecularColorUniform  , 0.5f, 0.5f, 0.5f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1f (  materialShininessUniform  , 50 )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int latitudeBands   = 30
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int longitudeBands   = 30
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int radius   = 2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices   = new  float  [ 3* (  latitudeBands  +1 )* (  longitudeBands  +1 ) ] 
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals   = new  float  [ 3* (  latitudeBands  +1 )* (  longitudeBands  +1 ) ] 
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords   = new  float  [ 2* (  latitudeBands  +1 )* (  longitudeBands  +1 ) ] 
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] sphereVertexIndices   = new  short  [ 6* latitudeBands  * longitudeBands   ] 
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int i   = 0 ; i   <=  latitudeBands   ; i   ++  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sinTheta   = ( float )  Math.sin   (  theta   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cosTheta   = ( float )  Math.cos   (  theta   )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int j   = 0 ; j   <=  longitudeBands   ; j   ++  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sinPhi   = ( float )  Math.sin   (  phi   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cosPhi   = ( float )  Math.cos   (  phi   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float x   =  cosPhi  * sinTheta  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float y   =  cosTheta  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float z   =  sinPhi  * sinTheta  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float u   = 1-( float ) j  / longitudeBands  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float v   = 1-( float ) i  / latitudeBands  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int index   = 3* (  j  + i  * (  longitudeBands  +1 ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices  [  index   ]  =  radius  * x  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices  [  index  +1 ]  =  radius  * y  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices  [  index  +2 ]  =  radius  * z  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals  [  index   ]  =  x  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals  [  index  +1 ]  =  y  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals  [  index  +2 ]  =  z  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> index    = 2* (  j  + i  * (  longitudeBands  +1 ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoords  [  index   ]  =  u  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoords  [  index  +1 ]  =  v  
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int i   = 0 ; i   <  latitudeBands   ; i   ++  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  sphereVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer  [ 2 ]  =  vertices.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  sphereVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer  [ 2 ]  =  normals.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  sphereVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexTextureCoordBuffer  [ 2 ]  =  textureCoords.length  /2
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  sphereVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  sphereVertexIndexBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  sphereVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  sphereVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer  [ 2 ]  =  sphereVertexIndices.length  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices2   = { -1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords2   = { 0.0f,10.0f,0.0f,0.0f,10.0f,0.0f,10.0f,10.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexNormalBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals2   = { 0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer  [ 2 ]  = 4
[METHOD_DECLARATION] ------->  public void initTexture   ( GL2 gl   ) throws IOException  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenTextures ( 2,  textures  , 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex1   =   TextureIO.newTextureData   ( new  File   (  "images  / bubble.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex1.getWidth   (  ),   tex1.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex1.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex2   =   TextureIO.newTextureData   ( new  File   (  "images  / grass.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex2.getWidth   (  ),   tex2.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex2.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D, 0 )
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.0f, 0.0f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BlendFunc ( GL2 .GL_ SRC_ALPHA, GL2 .GL_ ONE )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ BLEND )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  { 10,0,0,0,0,10,0,0,0,0,10,0,0,0, zoom  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normalMatrixv   =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  greenVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  greenVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  greenVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1f (  alphaUniform  , 1 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_STRIP, 0,  greenVertexPositionBuffer  [ 2 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    = new  float  [  ]  { 1,0,0,0,0,1,0,0,0,0,1,0,0,0, zoom  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    =   Util.multiplyMatrix   (  rotationMatrix  ,  mvMatrixv   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  sphereVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  sphereVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  sphereVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  sphereVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  sphereVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1f (  alphaUniform  , 0.8f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  sphereVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 1 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    =  timeNow  
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==90 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )
[METHOD_DECLARATION] ------->  public void mousePressed   ( MouseEvent e   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseX    =   e.getX   (  )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseY    =   e.getY   (  )
[METHOD_DECLARATION] ------->  public void mouseDragged   ( MouseEvent e   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int deltaX   =   e.getX   (  )- lastMouseX  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int deltaY   =   e.getY   (  )- lastMouseY  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> double rAnglex   =  deltaY  *0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> double rAngley   =  deltaX  *0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] newRotationMatrix   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,0,0,0,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rotationMatrix    =   Util.multiplyMatrix   (  rotationMatrix  ,  newRotationMatrix   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseX    =   e.getX   (  )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseY    =   e.getY   (  )

Test_va1Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.io.File  
[LIBRARY_DECLARATION] -------> import java.io.IOException  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import java.util.Arrays  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO  
[CLASS_DECLARATION] -------> public class Test_va1Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] doorVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] doorVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] textures   = new  int  [ 4 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAnglex   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double rAngley   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speedy   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zoom   = -8
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime2   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 6 ] 
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader2.fs"  ,  "shaders  / shader2.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aTextureCoord"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  textureCoordAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uSampler"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices1   = { 0.0f,1.0f,0.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices1.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices1   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer  [ 2 ]  = 6
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords1   = { 3.0f,0.0f,0.0f,6.0f,6.0f,6.0f,0.0f,6.0f,6.0f,6.0f,0.0f,6.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords1.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords1   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer  [ 2 ]  = 6
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices2   = { -1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 2 ]  = 16
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords2   = { 0.0f,0.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,0.0f,0.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,0.0f,0.0f,0.0f,0.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 2 ]  = 16
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] cubeVertexIndices   = { 0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15 }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  cubeVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices3   = { -1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices3.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices3   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords3   = { 0.0f,10.0f,0.0f,0.0f,10.0f,0.0f,10.0f,10.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords3.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords3   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  doorVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices4   = { -0.2f,-1.0f,1.001f,0.2f,-1.0f,1.001f,-0.2f,0.0f,1.001f,0.2f,0.0f,1.001f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices4.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices4   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  doorVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords4   = { 0.0f,1.0f,1.0f,1.0f,0.0f,0.0f,1.0f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords4.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords4   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer  [ 2 ]  = 4
[METHOD_DECLARATION] ------->  public void initTexture   ( GL2 gl   ) throws IOException  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenTextures ( 4,  textures  , 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex1   =   TextureIO.newTextureData   ( new  File   (  "images  / muro.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex1.getWidth   (  ),   tex1.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex1.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex2   =   TextureIO.newTextureData   ( new  File   (  "images  / roof.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex2.getWidth   (  ),   tex2.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex2.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex3   =   TextureIO.newTextureData   ( new  File   (  "images  / grass.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex3.getWidth   (  ),   tex3.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex3.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex4   =   TextureIO.newTextureData   ( new  File   (  "images  / door.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 3 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex4.getWidth   (  ),   tex4.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex4.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D, 0 )
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.71f, 0.91f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   (  rAnglex   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   (  rAngley   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,0,-cx, zoom  - sx  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  cubeVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  cubeVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  cubeVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  doorVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  doorVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 3 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_STRIP, 0,  doorVertexPositionBuffer  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Disable ( GL2 .GL_ CULL_FACE )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv2   =   Arrays.copyOf   (  mvMatrixv  ,  mvMatrixv.length   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 0 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 1 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 2 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 8 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 9 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 10 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  greenVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  greenVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_STRIP, 0,  greenVertexPositionBuffer  [ 2 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    =  mvMatrixv2  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 13 ] + = 2* cx  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 14 ] + = 2* sx  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  pyramidVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  pyramidVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_FAN, 0,  pyramidVertexPositionBuffer  [ 2 ] )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + =  speedx  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + =  speedy  * elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 1 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 2 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 3 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 4 ] )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 5 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    =  timeNow  
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==90 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==38 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==40 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==37 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==39 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )

Test_va2Drawer.java
[LIBRARY_DECLARATION] -------> package  test.jogl  
[LIBRARY_DECLARATION] -------> import java.awt.event.KeyEvent  
[LIBRARY_DECLARATION] -------> import java.io.File  
[LIBRARY_DECLARATION] -------> import java.io.IOException  
[LIBRARY_DECLARATION] -------> import java.nio.FloatBuffer  
[LIBRARY_DECLARATION] -------> import java.util.Arrays  
[LIBRARY_DECLARATION] -------> import javax.media.opengl.GL2  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util  
[LIBRARY_DECLARATION] -------> import test.jogl.util.Util.ObjModel  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.BufferUtil  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureData  
[LIBRARY_DECLARATION] -------> import com.sun.opengl.util.texture.TextureIO  
[CLASS_DECLARATION] -------> public class Test_va2Drawer
[ATTRIBUTE_DECLARATION] -------> private int vertexPositionAttribute   
[ATTRIBUTE_DECLARATION] -------> private int vertexNormalAttribute   
[ATTRIBUTE_DECLARATION] -------> private int textureCoordAttribute   
[ATTRIBUTE_DECLARATION] -------> private int pMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int mvMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int nMatrixUniform   
[ATTRIBUTE_DECLARATION] -------> private int samplerUniform   
[ATTRIBUTE_DECLARATION] -------> private int ambientColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingLocationUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingSpecularColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int pointLightingDiffuseColorUniform   
[ATTRIBUTE_DECLARATION] -------> private int materialShininessUniform   
[ATTRIBUTE_DECLARATION] -------> private int alphaUniform   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] doorVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] doorVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] doorVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] greenVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] pyramidVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] cubeVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] tractorVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] tractorVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] tractorVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] tractorVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] seagulVertexPositionBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] seagulVertexNormalBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] seagulVertexTextureCoordBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] seagulVertexIndexBuffer   = new  int  [ 3 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private int[] textures   = new  int  [ 6 ] 
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer pMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer mvMatrix   
[ATTRIBUTE_DECLARATION] -------> private FloatBuffer normalMatrix   
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private long lastTime   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private boolean[] commands   = new  boolean  [ 8 ] 
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double seagulAngle   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float tractorx   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double pitch   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double yaw   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float xPos   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float yStart   = -1.5f
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float yPos   =  yStart  
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float zPos   = 10
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float speed   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float lspeed   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float pitchRate   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private float yawRate   = 0
[ATTRIBUTE_DECLARATION, ATTRIBUTE_ASSIGNMENT, ASSIGNMENT] -------> private double joggingAngle   = 0
[METHOD_DECLARATION] ------->  public void initShaders   ( GL2 gl   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> int shaderProgram   =   Util.getShaderProgram   (  gl  ,  "shaders  / shader6.fs"  ,  "shaders  / shader6.vs"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexPosition"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexPositionAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aVertexNormal"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  vertexNormalAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    =  gl . gl GetAttribLocation (  shaderProgram  ,  "aTextureCoord"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl EnableVertexAttribArray (  textureCoordAttribute   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMVMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uNMatrix"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uSampler"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uAmbientColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingLocation"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingSpecularColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uPointLightingDiffuseColor"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uMaterialShininess"   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> alphaUniform    =  gl . gl GetUniformLocation (  shaderProgram  ,  "uAlpha"   )
[METHOD_DECLARATION] ------->  private void setMatrixUniforms   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  pMatrixUniform  , 16,  false  ,  pMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix4fv (  mvMatrixUniform  , 16,  false  ,  mvMatrix   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl UniformMatrix3fv (  nMatrixUniform  , 9,  false  ,  normalMatrix   )
[METHOD_DECLARATION] ------->  public void initBuffers   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices1   = { 0.0f,1.0f,0.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,0.0f,1.0f,0.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,0.0f,1.0f,0.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,0.0f,1.0f,0.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices1.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices1   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer  [ 2 ]  = 12
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexNormalBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals1   = { -0.89442719099991587856366946749251f,0.44721359549995793928183473374626f,0.0f,-0.89442719099991587856366946749251f,0.44721359549995793928183473374626f,0.0f,-0.89442719099991587856366946749251f,0.44721359549995793928183473374626f,0.0f,0.0f,0.44721359549995793928183473374626f,-0.89442719099991587856366946749251f,0.0f,0.44721359549995793928183473374626f,-0.89442719099991587856366946749251f,0.0f,0.44721359549995793928183473374626f,-0.89442719099991587856366946749251f,0.0f,0.44721359549995793928183473374626f,0.89442719099991587856366946749251f,0.0f,0.44721359549995793928183473374626f,0.89442719099991587856366946749251f,0.0f,0.44721359549995793928183473374626f,0.89442719099991587856366946749251f,0.89442719099991587856366946749251f,0.44721359549995793928183473374626f,0.0f,0.89442719099991587856366946749251f,0.44721359549995793928183473374626f,0.0f,0.89442719099991587856366946749251f,0.44721359549995793928183473374626f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals1.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals1   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexNormalBuffer  [ 2 ]  = 12
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords1   = { 3.0f,0.0f,0.0f,6.0f,6.0f,6.0f,3.0f,0.0f,0.0f,6.0f,6.0f,6.0f,3.0f,0.0f,6.0f,6.0f,0.0f,6.0f,3.0f,0.0f,0.0f,6.0f,6.0f,6.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords1.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords1   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer  [ 2 ]  = 12
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  pyramidVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  pyramidVertexIndexBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] pyramidVertexIndices   = { 0,1,2,3,5,4,6,7,8,9,10,11 }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  pyramidVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  pyramidVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexIndexBuffer  [ 2 ]  = 12
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices2   = { -1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f,1.0f,-1.0f,1.0f,-1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer  [ 2 ]  = 16
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexNormalBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals2   = { 0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f,-1.0f,0.0f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer  [ 2 ]  = 16
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords2   = { 0.0f,0.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,0.0f,0.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f,0.0f,0.0f,0.0f,0.0f,10.0f,0.0f,10.0f,10.0f,0.0f,10.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords2.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords2   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer  [ 2 ]  = 16
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  cubeVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> short[] cubeVertexIndices   = { 0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15 }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  cubeVertexIndices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer  [ 2 ]  = 24
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices3   = { -1.0f,-1.0f,-1.0f,-1.0f,-1.0f,1.0f,1.0f,-1.0f,-1.0f,1.0f,-1.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices3.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices3   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexNormalBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals3   = { 0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals3.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals3   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  greenVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords3   = { 0.0f,10.0f,0.0f,0.0f,10.0f,0.0f,10.0f,10.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords3.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords3   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  doorVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexPositionBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] vertices4   = { -0.2f,-1.0f,1.001f,0.2f,-1.0f,1.001f,-0.2f,0.0f,1.001f,0.2f,0.0f,1.001f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  vertices4.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  vertices4   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  doorVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexNormalBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normals4   = { 0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f,0.0f,0.0f,1.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  normals4.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  normals4   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexNormalBuffer  [ 2 ]  = 4
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  doorVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexTextureCoordBuffer  [ 0 ] )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] textureCoords4   = { 0.0f,1.0f,1.0f,1.0f,0.0f,0.0f,1.0f,0.0f }
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  textureCoords4.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  textureCoords4   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer  [ 2 ]  = 4
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ObjModel tractor   =   Util.loadObj   (  "models  / tractor.obj"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  tractorVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  tractorVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  tractor.vertexPositions.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  tractor.vertexPositions   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexPositionBuffer  [ 2 ]  =  tractor.vertexPositions.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  tractorVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  tractorVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  tractor.vertexNormals.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  tractor.vertexNormals   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexNormalBuffer  [ 2 ]  =  tractor.vertexNormals.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  tractorVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  tractorVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  tractor.vertexTextureCoords.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  tractor.vertexTextureCoords   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexTextureCoordBuffer  [ 2 ]  =  tractor.vertexTextureCoords.length  /2
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  tractorVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  tractorVertexIndexBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  tractor.indices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  tractor.indices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexIndexBuffer  [ 2 ]  =  tractor.indices.length  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ObjModel seagul   =   Util.loadObj   (  "models  / seagul.obj"   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  seagulVertexPositionBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  seagulVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  seagul.vertexPositions.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  seagul.vertexPositions   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexPositionBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexPositionBuffer  [ 2 ]  =  seagul.vertexPositions.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  seagulVertexNormalBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  seagulVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  seagul.vertexNormals.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  seagul.vertexNormals   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexNormalBuffer  [ 1 ]  = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexNormalBuffer  [ 2 ]  =  seagul.vertexNormals.length  /3
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  seagulVertexTextureCoordBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  seagulVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ARRAY_BUFFER,  seagul.vertexTextureCoords.length  * BufferUtil.SIZEOF_FLOAT  ,   BufferUtil.newFloatBuffer   (  seagul.vertexTextureCoords   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexTextureCoordBuffer  [ 1 ]  = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexTextureCoordBuffer  [ 2 ]  =  seagul.vertexTextureCoords.length  /2
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenBuffers ( 1,  seagulVertexIndexBuffer  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  seagulVertexIndexBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BufferData ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  seagul.indices.length  * BufferUtil.SIZEOF_SHORT  ,   BufferUtil.newShortBuffer   (  seagul.indices   ), GL2 .GL_ STATIC_DRAW )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexIndexBuffer  [ 1 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexIndexBuffer  [ 2 ]  =  seagul.indices.length  
[METHOD_DECLARATION] ------->  public void initTexture   ( GL2 gl   ) throws IOException  
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenTextures ( 6,  textures  , 0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex1   =   TextureIO.newTextureData   ( new  File   (  "images  / muro.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex1.getWidth   (  ),   tex1.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex1.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex2   =   TextureIO.newTextureData   ( new  File   (  "images  / roof.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex2.getWidth   (  ),   tex2.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex2.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex3   =   TextureIO.newTextureData   ( new  File   (  "images  / grass.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex3.getWidth   (  ),   tex3.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex3.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex4   =   TextureIO.newTextureData   ( new  File   (  "images  / door.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 3 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex4.getWidth   (  ),   tex4.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex4.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex5   =   TextureIO.newTextureData   ( new  File   (  "images  / tractor.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 4 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex5.getWidth   (  ),   tex5.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex5.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ MIRRORED_REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ MIRRORED_REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> TextureData tex6   =   TextureIO.newTextureData   ( new  File   (  "images  / seagul.gif"   ),  false  ,  null   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 5 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexImage2D ( GL2 .GL_ TEXTURE_2D, 0, GL2 .GL_ RGB,   tex6.getWidth   (  ),   tex6.getHeight   (  ), 0, GL2 .GL_ RGB, GL2 .GL_ UNSIGNED_BYTE,   tex6.getBuffer   (  ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MAG_FILTER, GL2 .GL_ LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_MIN_FILTER, GL2 .GL_ LINEAR_MIPMAP_LINEAR )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_S, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl TexParameteri ( GL2 .GL_ TEXTURE_2D, GL2 .GL_ TEXTURE_WRAP_T, GL2 .GL_ REPEAT )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl GenerateMipmap ( GL2 .GL_ TEXTURE_2D )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D, 0 )
[METHOD_DECLARATION] ------->  public void drawScene   ( GL2 gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ClearColor ( 0.0f, 0.71f, 0.91f, 1.0f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ DEPTH_TEST )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl CullFace ( GL2 .GL_ BACK )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[CALL, LINE_OF_CODE] ------->   handleKeys   (  )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Viewport ( 0, 0, 500, 500 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Clear ( GL2 .GL_ COLOR_BUFFER_BIT|GL2 .GL_ DEPTH_BUFFER_BIT )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cx   = ( float )  Math.cos   ( -pitch )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sx   = ( float )  Math.sin   ( -pitch )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cy   = ( float )  Math.cos   ( -yaw )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float sy   = ( float )  Math.sin   ( -yaw )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] pMatrixv   = new  float  [  ]  { 2.4142136573791504f,0,0,0,0,2.4142136573791504f,0,0,0,0,-1.0020020008087158f,-1,0,0,-0.20020020008087158f,0 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    =   BufferUtil.newFloatBuffer   (  pMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv   = new  float  [  ]  {  cy  , sx  * sy  ,-cx* sy  ,0,0, cx  , sx  ,0, sy  ,-cy* sx  , cx  * cy  ,0,-cy* xPos  - sy  * zPos  ,-cx- sx  * sy  * xPos  - cx  * yPos  + cy  * sx  * zPos  ,-sx+ cx  * sy  * xPos  - sx  * yPos  - cx  * cy  * zPos  ,1 }
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] normalMatrixv   =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  ambientColorUniform  , 0.1f, 0.1f, 0.1f )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] lightLoc   = new  float  [  ]  { 0,4,2,1 }
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] tlightLoc   =   Util.multiplyMatrixVector   (  pMatrixv  ,   Util.multiplyMatrixVector   (  mvMatrixv  ,  lightLoc   ) )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingLocationUniform  ,  tlightLoc  [ 0 ],  tlightLoc  [ 1 ],  tlightLoc  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingDiffuseColorUniform  , 0.5f, 0.5f, 0.5f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform3f (  pointLightingSpecularColorUniform  , 0.5f, 0.5f, 0.5f )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1f (  materialShininessUniform  , 50 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1f (  alphaUniform  , 1 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl FrontFace ( GL2 .GL_ CCW )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  cubeVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  cubeVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  cubeVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  cubeVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl ActiveTexture ( GL2 .GL_ TEXTURE0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  cubeVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  cubeVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  doorVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  doorVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  doorVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  doorVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 3 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_STRIP, 0,  doorVertexPositionBuffer  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Disable ( GL2 .GL_ CULL_FACE )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float[] mvMatrixv2   =   Arrays.copyOf   (  mvMatrixv  ,  mvMatrixv.length   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 0 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 1 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 2 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 8 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 9 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 10 ] * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  greenVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  greenVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  greenVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  greenVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 2 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawArrays ( GL2 .GL_ TRIANGLE_STRIP, 0,  greenVertexPositionBuffer  [ 2 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    =   Arrays.copyOf   (  mvMatrixv2  ,  mvMatrixv2.length   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Enable ( GL2 .GL_ CULL_FACE )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 13 ] + = 2* cx  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 14 ] + = 2* sx  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  pyramidVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  pyramidVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  pyramidVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  pyramidVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 1 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  pyramidVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  pyramidVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    =   Arrays.copyOf   (  mvMatrixv2  ,  mvMatrixv2.length   )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( int i   = 0 ; i   < 12 ; i   ++  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float xt   = -11+ tractorx  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float yt   = -1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float zt   = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 12 ] + =  cy  * xt  + sy  * zt  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 13 ] + =  sx  * sy  * xt  + cx  * yt  - cy  * sx  * zt  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 14 ] + = -cx* sy  * xt  + sx  * yt  + cx  * cy  * zt  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  tractorVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  tractorVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  tractorVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  tractorVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  tractorVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  tractorVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 4 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  tractorVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  tractorVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv    =  mvMatrixv2  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float cs   = ( float )  Math.cos   (  seagulAngle   )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float ss   = ( float )  Math.sin   (  seagulAngle   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> xt    = -3* cs  - xPos  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yt    = 2- yPos  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zt    = 4* ss  - zPos  
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> float s   = 0.3f
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 0 ]  =  cs  * cy  * s  - s  * ss  * sy  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 1 ]  =  cy  * s  * ss  * sx  + cs  * s  * sx  * sy  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 2 ]  = -cx* cy  * s  * ss  - cs  * cx  * s  * sy  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 3 ]  = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 4 ]  = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 5 ]  =  cx  * s  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 6 ]  =  s  * sx  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 7 ]  = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 8 ]  =  cy  * s  * ss  + cs  * s  * sy  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 9 ]  = -cs* cy  * s  * sx  + s  * ss  * sx  * sy  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 10 ]  =  cs  * cx  * cy  * s  - cx  * s  * ss  * sy  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 11 ]  = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 12 ]  =  cy  * xt  + sy  * zt  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 13 ]  = -cx+ sx  * sy  * xt  + cx  * yt  - cy  * sx  * zt  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 14 ]  = -sx- cx  * sy  * xt  + sx  * yt  + cx  * cy  * zt  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixv  [ 15 ]  = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    =   BufferUtil.newFloatBuffer   (  mvMatrixv   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrixv    =   Util.mat3Traspose   (   Util.mat4ToInverseMat3   (  mvMatrixv   ) )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    =   BufferUtil.newFloatBuffer   (  normalMatrixv   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  seagulVertexPositionBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexPositionAttribute  ,  seagulVertexPositionBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  seagulVertexNormalBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  vertexNormalAttribute  ,  seagulVertexNormalBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ARRAY_BUFFER,  seagulVertexTextureCoordBuffer  [ 0 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl VertexAttribPointer (  textureCoordAttribute  ,  seagulVertexTextureCoordBuffer  [ 1 ], GL2 .GL_ FLOAT,  false  , 0, 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindTexture ( GL2 .GL_ TEXTURE_2D,  textures  [ 5 ] )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl Uniform1i (  samplerUniform  , 0 )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl BindBuffer ( GL2 .GL_ ELEMENT_ARRAY_BUFFER,  seagulVertexIndexBuffer  [ 0 ] )
[CALL, LINE_OF_CODE] ------->   setMatrixUniforms   (  gl   )
[OPENGL_CALL, LINE_OF_CODE] ------->  gl . gl DrawElements ( GL2 .GL_ TRIANGLES,  seagulVertexIndexBuffer  [ 2 ], GL2 .GL_ UNSIGNED_SHORT, 0 )
[CALL, LINE_OF_CODE] ------->   animate   (  )
[METHOD_DECLARATION] ------->  private void animate   (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> long timeNow   =   System.currentTimeMillis   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> boolean move   =  false  
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( speed  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zPos   - =   Math.cos   (  yaw   )* speed  * elapsed  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> move    =  true  
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lspeed  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zPos   - =   Math.sin   (  yaw   )* lspeed  * elapsed  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> move    =  true  
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( move   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yPos    = ( float ) (   Math.sin   (  joggingAngle   )/20+ yStart   )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yaw   + =  yawRate  * elapsed  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitch   + =  pitchRate  * elapsed  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulAngle   + = 0.0008* elapsed  
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorx   + = 0.0008* elapsed  
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( tractorx  >22 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    =  timeNow  
[METHOD_DECLARATION] ------->  private void handleKeys   (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 0 ] )
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands  [ 1 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = -0.003f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 2 ] )
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands  [ 3 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = -0.00174f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 4 ] )
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands  [ 5 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = -0.00174f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands  [ 6 ] )
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands  [ 7 ] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = -0.003f
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = 0
[METHOD_DECLARATION] ------->  private void setCommands   ( KeyEvent e  , boolean value   )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==87 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==83 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==38 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==40 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==37 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==39 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==68 )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if (   e.getKeyCode   (  )==65 )
[METHOD_DECLARATION] ------->  public void keyPressed   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  true   )
[METHOD_DECLARATION] ------->  public void keyReleased   ( KeyEvent e   )
[CALL, LINE_OF_CODE] ------->   setCommands   (  e  ,  false   )
