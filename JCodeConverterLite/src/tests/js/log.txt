
test_sv1Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexColorAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  triangleVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  triangleVertexColorBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  squareVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  squareVertexColorBuffer   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[CONSTRUCTOR_DECLARATION] -------> function Test_sv1Drawer (  )
[CLASS_DECLARATION] -------> Test_sv1Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader1.fs", "shaders/shader1.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexColorAttribute    = gl.getAttribLocation(shaderProgram, "aVertexColor")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexColorAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices   = [  0.0,1.0,0.0,-1.0,-1.0,0.0,1.0,-1.0,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexPositionBuffer[2]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexColorBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  colors   = [  1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(colors), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> triangleVertexColorBuffer[2]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices2   = [  1.0,1.0,0.0,-1.0,1.0,0.0,1.0,-1.0,0.0,-1.0,-1.0,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexPositionBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexColorBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  colors2   = []
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 4 ; i++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  c   = i  <<2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c  +1]    = 0.75
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c  +2]    = 0.8
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> colors2[c  +3]    = 1
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(colors2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> squareVertexColorBuffer[2]    = 4
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,4])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  1,0,0,0,0,1,0,0,0,0,1,0,-1.5,0,0,1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, triangleVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexColorAttribute, triangleVertexColorBuffer[1], gl.FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  1,0,0,0,0,1,0,0,0,0,1,0,1.5,0,0,1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, squareVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexColorAttribute, squareVertexColorBuffer[1], gl.FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer[2])

test_sv2Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexColorAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexColorBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  baseVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  baseVertexColorBuffer   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngle   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[CONSTRUCTOR_DECLARATION] -------> function Test_sv2Drawer (  )
[CLASS_DECLARATION] -------> Test_sv2Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader1.fs", "shaders/shader1.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexColorAttribute    = gl.getAttribLocation(shaderProgram, "aVertexColor")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexColorAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices   = [  0.0,1.0,0.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[2]    = 6
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexColorBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  colors   = [  1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(colors), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexColorBuffer[2]    = 6
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, baseVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices2   = [  -1.0,-1.0,-1.0,-1.0,-1.0,1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexPositionBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexColorBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, baseVertexColorBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  colors2   = [  0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(colors2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexColorBuffer[1]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> baseVertexColorBuffer[2]    = 4
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAngle)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cx,sx  *sx,-cx*sx,0,0,cx,sx,0,sx,-cx*sx,cx  *cx,0,0,0,-8,1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, pyramidVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexColorAttribute, pyramidVertexColorBuffer[1], gl.FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_FAN, 0, pyramidVertexPositionBuffer[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, baseVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, baseVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, baseVertexColorBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexColorAttribute, baseVertexColorBuffer[1], gl.FLOAT, false, 0, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_STRIP, 0, baseVertexPositionBuffer[2])
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngle   + = 1.57*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow

test_sv3Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  textureCoordAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  samplerUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  texture1   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngle   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[CONSTRUCTOR_DECLARATION] -------> function Test_sv3Drawer (  )
[CLASS_DECLARATION] -------> Test_sv3Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderProgram.textureCoordAttribute    = gl.getAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.getUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices    = [  -1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords   = [  0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndices   = [  0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(cubeVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] -------> , initTexture : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> texture1[0]    = gl.createTexture()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, texture1[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, null)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.src    = "images/crate.gif"
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAngle)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cx  *cx,cx  *(sx  *sx  +sx),sx  *sx  -cx  *cx  *sx,0,-cx*sx,cx  *cx  -sx  *sx  *sx,cx  *(sx  *sx  +sx),0,sx,-cx*sx,cx  *cx,0,0,0,-8,1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, texture1[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngle   + = 1.57*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow

test_sv4Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  textureCoordAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  samplerUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textures   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAnglex   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedx   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngley   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedy   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zoom   = -8
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime2   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  filter   = 0
[CONSTRUCTOR_DECLARATION] -------> function Test_sv4Drawer (  )
[CLASS_DECLARATION] -------> Test_sv4Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderProgram.textureCoordAttribute    = gl.getAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.getUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices   = [  -1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords   = [  0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndices   = [  0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(cubeVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] -------> , initTexture : function ( gl )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textures[i]    = gl.createTexture()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, null)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.src    = "images/crate.gif"
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(rAngley)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,0,0,zoom,1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[filter])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==70 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> filter    = filter  ==2?  0:  (filter  +1)
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)

test_sv5Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  textureCoordAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  samplerUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textures   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAnglex   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedx   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngley   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedy   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zoom   = -8
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime2   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  wrapper   = 0
[CONSTRUCTOR_DECLARATION] -------> function Test_sv5Drawer (  )
[CLASS_DECLARATION] -------> Test_sv5Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderProgram.textureCoordAttribute    = gl.getAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.getUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices   = [  -1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords   = [  -1.0,-1.0,2.0,-1.0,2.0,2.0,-1.0,2.0,2.0,-1.0,2.0,2.0,-1.0,2.0,-1.0,-1.0,-1.0,2.0,-1.0,-1.0,2.0,-1.0,2.0,2.0,2.0,2.0,-1.0,2.0,-1.0,-1.0,2.0,-1.0,2.0,-1.0,2.0,2.0,-1.0,2.0,-1.0,-1.0,-1.0,-1.0,2.0,-1.0,2.0,2.0,-1.0,2.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndices   = [  0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(cubeVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] -------> , initTexture : function ( gl )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textures[i]    = gl.createTexture()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, null)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.src    = "images/roof.gif"
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(rAngley)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,0,0,zoom,1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[wrapper])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==87 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> wrapper    = wrapper  ==2?  0:  (wrapper  +1)
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)

test_sv6Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexNormalAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  textureCoordAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  nMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  samplerUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  ambientColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  lightingDirectionUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  directionalColorUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textures   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  normalMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAnglex   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedx   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngley   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedy   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zoom   = -8
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime2   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[CONSTRUCTOR_DECLARATION] -------> function Test_sv6Drawer (  )
[CLASS_DECLARATION] -------> Test_sv6Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader3.fs", "shaders/shader3.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.getAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.getAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.getUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.getUniformLocation(shaderProgram, "uSampler")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.getUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lightingDirectionUniform    = gl.getUniformLocation(shaderProgram, "uLightingDirection")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> directionalColorUniform    = gl.getUniformLocation(shaderProgram, "uDirectionalColor")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix3fv(nMatrixUniform, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(ambientColorUniform, 0.1, 0.1, 0.1)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lightingDirection   = [  0.57735026918962576450914878050196,0.57735026918962576450914878050196,0.57735026918962576450914878050196]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3fv(lightingDirectionUniform, lightingDirection)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(directionalColorUniform, 0.7, 0.7, 0.7)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices   = [  -1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals   = [  0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords   = [  -1.0,-1.0,2.0,-1.0,2.0,2.0,-1.0,2.0,2.0,-1.0,2.0,2.0,-1.0,2.0,-1.0,-1.0,-1.0,2.0,-1.0,-1.0,2.0,-1.0,2.0,2.0,2.0,2.0,-1.0,2.0,-1.0,-1.0,2.0,-1.0,2.0,-1.0,2.0,2.0,-1.0,2.0,-1.0,-1.0,-1.0,-1.0,2.0,-1.0,2.0,2.0,-1.0,2.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndices   = [  0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(cubeVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 36
[METHOD_DECLARATION] -------> , initTexture : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textures[0]    = gl.createTexture()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, null)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex.src    = "images/muro.gif"
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(rAngley)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,0,0,zoom,1])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, cubeVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)

test_sv7Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexNormalAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  nMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  ambientColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingLocationUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  shaderUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderChoice   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  normalMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAnglex   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedx   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngley   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedy   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zoom   = -8
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime2   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[CONSTRUCTOR_DECLARATION] -------> function Test_sv7Drawer (  )
[CLASS_DECLARATION] -------> Test_sv7Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader4.fs", "shaders/shader4.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.getAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.getUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.getUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingColorUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderUniform    = gl.getUniformLocation(shaderProgram, "uShader")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix3fv(nMatrixUniform, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(ambientColorUniform, 0.1, 0.1, 0.1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingLocationUniform, 0, 0, -5.1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingColorUniform, 0.7, 0.7, 0.7)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  latitudeBands   = 15
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  longitudeBands   = 15
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  radius   = 2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexIndices   = new  Array()
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   <= latitudeBands ; i++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  theta   = i  *Math.PI  /latitudeBands
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sinTheta   = Math.sin(theta)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cosTheta   = Math.cos(theta)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   <= longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  phi   = (j  *2*Math.PI  /longitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sinPhi   = Math.sin(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cosPhi   = Math.cos(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  x   = cosPhi  *sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  y   = cosTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  z   = sinPhi  *sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  index   = 3*(j  +i  *(longitudeBands  +1))
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index]    = radius  *x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index  +1]    = radius  *y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index  +2]    = radius  *z
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index]    = x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index  +1]    = y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index  +2]    = z
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < latitudeBands ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  first   = (i  *(longitudeBands  +1))  +j
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  second   = first  +longitudeBands  +1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  index   = 6*(j  +i  *longitudeBands)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index]    = first
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +1]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +2]    = first  +1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +3]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +4]    = second  +1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +5]    = first  +1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[2]    = vertices.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[2]    = vertices.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(sphereVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[2]    = sphereVertexIndices.length
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(shaderUniform, shaderChoice)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(rAngley)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,0,0,zoom,1])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, sphereVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, sphereVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, sphereVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==83 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderChoice    = shaderChoice  ==1?  0:  (shaderChoice  +1)
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)

test_sv8Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexNormalAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  nMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  ambientColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingLocationUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingSpecularColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingDiffuseColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  materialShininessUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  teapotVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  teapotVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  teapotVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  normalMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAnglex   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedx   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngley   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedy   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zoom   = -8
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime2   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[CONSTRUCTOR_DECLARATION] -------> function Test_sv8Drawer (  )
[CLASS_DECLARATION] -------> Test_sv8Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader5.fs", "shaders/shader5.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.getAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.getUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.getUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    = gl.getUniformLocation(shaderProgram, "uMaterialShininess")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix3fv(nMatrixUniform, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(ambientColorUniform, 0.1, 0.1, 0.1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingLocationUniform, -1, 0, -5.1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingDiffuseColorUniform, 0.7, 0.7, 0.7)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingSpecularColorUniform, 0.7, 0.7, 0.7)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1f(materialShininessUniform, 10)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  teapot   = loadObj("models/teapot.obj")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(teapot.vertexPositions), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexPositionBuffer[2]    = teapot.vertexPositions.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(teapot.vertexNormals), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexNormalBuffer[2]    = teapot.vertexNormals.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(teapot.indices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> teapotVertexIndexBuffer[2]    = teapot.indices.length
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(rAngley)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,0,0,zoom,1])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, teapotVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, teapotVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, teapotVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)

test_sv9Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexNormalAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  textureCoordAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  nMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  samplerUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  ambientColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingLocationUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingSpecularColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingDiffuseColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  materialShininessUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  alphaUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textures   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  normalMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zoom   = -8
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime2   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastMouseX   = -1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastMouseY   = -1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rotationMatrix   = new  Float32Array([  1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])
[CONSTRUCTOR_DECLARATION] -------> function Test_sv9Drawer (  )
[CLASS_DECLARATION] -------> Test_sv9Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader6.fs", "shaders/shader6.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.getAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoordAttribute    = gl.getAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.getUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.getUniformLocation(shaderProgram, "uSampler")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.getUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    = gl.getUniformLocation(shaderProgram, "uMaterialShininess")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> alphaUniform    = gl.getUniformLocation(shaderProgram, "uAlpha")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix3fv(nMatrixUniform, false, normalMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(ambientColorUniform, 0.1, 0.1, 0.1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingLocationUniform, -10, 0, 5)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingDiffuseColorUniform, 0.4, 0.4, 0.4)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingSpecularColorUniform, 0.5, 0.5, 0.5)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1f(materialShininessUniform, 50)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  latitudeBands   = 30
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  longitudeBands   = 30
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  radius   = 2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sphereVertexIndices   = new  Array()
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   <= latitudeBands ; i++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  theta   = i  *Math.PI  /latitudeBands
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sinTheta   = Math.sin(theta)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cosTheta   = Math.cos(theta)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   <= longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  phi   = (j  *2*Math.PI  /longitudeBands)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sinPhi   = Math.sin(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cosPhi   = Math.cos(phi)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  x   = cosPhi  *sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  y   = cosTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  z   = sinPhi  *sinTheta
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  u   = 1-j  /longitudeBands
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  v   = 1-i  /latitudeBands
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  index   = 3*(j  +i  *(longitudeBands  +1))
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index]    = radius  *x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index  +1]    = radius  *y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertices[index  +2]    = radius  *z
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index]    = x
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index  +1]    = y
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normals[index  +2]    = z
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> index    = 2*(j  +i  *(longitudeBands  +1))
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoords[index]    = u
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textureCoords[index  +1]    = v
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < latitudeBands ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < longitudeBands ; j++ )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  first   = (i  *(longitudeBands  +1))  +j
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  second   = first  +longitudeBands  +1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  index   = 6*(j  +i  *longitudeBands)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index]    = first
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +1]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +2]    = first  +1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +3]    = second
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +4]    = second  +1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndices[index  +5]    = first  +1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexPositionBuffer[2]    = vertices.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexNormalBuffer[2]    = vertices.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexTextureCoordBuffer[2]    = textureCoords.length  /2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(sphereVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> sphereVertexIndexBuffer[2]    = sphereVertexIndices.length
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices2   = [  -1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords2   = [  0.0,10.0,0.0,0.0,10.0,0.0,10.0,10.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals2   = [  0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[2]    = 4
[METHOD_DECLARATION] -------> , initTexture : function ( gl )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 2 ; i++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textures[i]    = gl.createTexture()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex1   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1.src    = "images/bubble.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex2   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex2)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, null)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2.src    = "images/grass.gif"
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.0, 0.0, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.BLEND)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  10,0,0,0,0,10,0,0,0,0,10,0,0,0,zoom,1])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, greenVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, greenVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, greenVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1f(alphaUniform, 1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_STRIP, 0, greenVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  1,0,0,0,0,1,0,0,0,0,1,0,0,0,zoom,1])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = multiplyMatrix(rotationMatrix, mvMatrix)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, sphereVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, sphereVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, sphereVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1f(alphaUniform, 0.8)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, sphereVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)
[METHOD_DECLARATION] -------> , mousePressed : function ( e )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseX    = e.clientX
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseY    = e.clientY
[METHOD_DECLARATION] -------> , mouseDragged : function ( e )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  deltaX   = e.clientX  -lastMouseX
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  deltaY   = e.clientY  -lastMouseY
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAnglex   = deltaY  *0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngley   = deltaX  *0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  newRotationMatrix   = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,0,0,0,1])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rotationMatrix    = multiplyMatrix(rotationMatrix, newRotationMatrix)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseX    = e.clientX
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastMouseY    = e.clientY

test_va1Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  textureCoordAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  samplerUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  doorVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  doorVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textures   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAnglex   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedx   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  rAngley   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speedy   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zoom   = -8
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime2   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[CONSTRUCTOR_DECLARATION] -------> function Test_va1Drawer (  )
[CLASS_DECLARATION] -------> Test_va1Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader2.fs", "shaders/shader2.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderProgram.textureCoordAttribute    = gl.getAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.getUniformLocation(shaderProgram, "uSampler")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices1   = [  0.0,1.0,0.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices1), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[2]    = 6
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords1   = [  3.0,0.0,0.0,6.0,6.0,6.0,0.0,6.0,6.0,6.0,0.0,6.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords1), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[2]    = 6
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices2   = [  -1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 16
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords2   = [  0.0,0.0,10.0,0.0,10.0,10.0,0.0,10.0,10.0,0.0,10.0,10.0,0.0,10.0,0.0,0.0,10.0,0.0,10.0,10.0,0.0,10.0,0.0,0.0,0.0,0.0,10.0,0.0,10.0,10.0,0.0,10.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 16
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndices   = [  0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(cubeVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices3   = [  -1.0,-1.0,-1.0,-1.0,-1.0,1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices3), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords3   = [  0.0,10.0,0.0,0.0,10.0,0.0,10.0,10.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords3), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices4   = [  -0.2,-1.0,1.001,0.2,-1.0,1.001,-0.2,0.0,1.001,0.2,0.0,1.001]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices4), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords4   = [  0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords4), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[2]    = 4
[METHOD_DECLARATION] -------> , initTexture : function ( gl )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 4 ; i++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textures[i]    = gl.createTexture()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex1   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1.src    = "images/muro.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex2   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex2)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2.src    = "images/roof.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex3   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex3)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3.src    = "images/grass.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex4   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex4)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, null)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4.src    = "images/door.gif"
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.71, 0.91, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(rAnglex)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(rAngley)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(rAngley)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,0,-cx,zoom  -sx,1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, doorVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, doorVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_STRIP, 0, doorVertexPositionBuffer[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.disable(gl.CULL_FACE)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix2    = new  Float32Array(mvMatrix)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[0]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[1]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[2]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[8]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[9]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[10]   * = 10
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, greenVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, greenVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_STRIP, 0, greenVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = mvMatrix2
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[13]   + = 2*cx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[14]   + = 2*sx
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, pyramidVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, pyramidVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_FAN, 0, pyramidVertexPositionBuffer[2])
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAnglex   + = speedx  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> rAngley   + = speedy  *elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime2  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime2
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   + = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zoom   - = 5*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedx   + = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   - = 2*elapsed  *0.001
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speedy   + = 2*elapsed  *0.001
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime2    = timeNow
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==90 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==87 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> wrapper    = wrapper  ==2?  0:  (wrapper  +1)
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)

test_va2Drawer.js
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexPositionAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  vertexNormalAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  textureCoordAttribute
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  nMatrixUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  samplerUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  ambientColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingLocationUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingSpecularColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pointLightingDiffuseColorUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  materialShininessUniform
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  alphaUniform
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  doorVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  doorVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  doorVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  greenVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pyramidVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tractorVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tractorVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tractorVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tractorVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  seagulVertexPositionBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  seagulVertexNormalBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  seagulVertexTextureCoordBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  seagulVertexIndexBuffer   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textures   = new  Array()
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  pMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  mvMatrix
[VARIABLE_DECLARATION, LINE_OF_CODE] -------> var  normalMatrix
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lastTime   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  commands   = new  Array()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  seagulAngle   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tractorx   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pitch   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  yaw   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  xPos   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  yStart   = -1.5
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  yPos   = yStart
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zPos   = 10
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  speed   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lspeed   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  pitchRate   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  yawRate   = 0
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  joggingAngle   = 0
[CONSTRUCTOR_DECLARATION] -------> function Test_va2Drawer (  )
[CLASS_DECLARATION] -------> Test_va2Drawer . prototype =
[METHOD_DECLARATION] ------->  initShaders : function ( gl )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  shaderProgram   = getShaderProgram(gl, "shaders/shader6.fs", "shaders/shader6.vs")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexPositionAttribute    = gl.getAttribLocation(shaderProgram, "aVertexPosition")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexPositionAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> vertexNormalAttribute    = gl.getAttribLocation(shaderProgram, "aVertexNormal")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(vertexNormalAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> shaderProgram.textureCoordAttribute    = gl.getAttribLocation(shaderProgram, "aTextureCoord")
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enableVertexAttribArray(textureCoordAttribute)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrixUniform    = gl.getUniformLocation(shaderProgram, "uPMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrixUniform    = gl.getUniformLocation(shaderProgram, "uMVMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> nMatrixUniform    = gl.getUniformLocation(shaderProgram, "uNMatrix")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> samplerUniform    = gl.getUniformLocation(shaderProgram, "uSampler")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> ambientColorUniform    = gl.getUniformLocation(shaderProgram, "uAmbientColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingLocationUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingLocation")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingSpecularColorUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pointLightingDiffuseColorUniform    = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> materialShininessUniform    = gl.getUniformLocation(shaderProgram, "uMaterialShininess")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> alphaUniform    = gl.getUniformLocation(shaderProgram, "uAlpha")
[METHOD_DECLARATION] -------> , setMatrixUniforms : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniformMatrix3fv(nMatrixUniform, false, normalMatrix)
[METHOD_DECLARATION] -------> , initBuffers : function ( gl )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices1   = [  0.0,1.0,0.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,0.0,1.0,0.0,-1.0,-1.0,-1.0,1.0,-1.0,-1.0,0.0,1.0,0.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,0.0,1.0,0.0,1.0,-1.0,1.0,1.0,-1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices1), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexPositionBuffer[2]    = 12
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals1   = [  -0.89442719099991587856366946749251,0.44721359549995793928183473374626,0.0,-0.89442719099991587856366946749251,0.44721359549995793928183473374626,0.0,-0.89442719099991587856366946749251,0.44721359549995793928183473374626,0.0,0.0,0.44721359549995793928183473374626,-0.89442719099991587856366946749251,0.0,0.44721359549995793928183473374626,-0.89442719099991587856366946749251,0.0,0.44721359549995793928183473374626,-0.89442719099991587856366946749251,0.0,0.44721359549995793928183473374626,0.89442719099991587856366946749251,0.0,0.44721359549995793928183473374626,0.89442719099991587856366946749251,0.0,0.44721359549995793928183473374626,0.89442719099991587856366946749251,0.89442719099991587856366946749251,0.44721359549995793928183473374626,0.0,0.89442719099991587856366946749251,0.44721359549995793928183473374626,0.0,0.89442719099991587856366946749251,0.44721359549995793928183473374626,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals1), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexNormalBuffer[2]    = 12
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords1   = [  3.0,0.0,0.0,6.0,6.0,6.0,3.0,0.0,0.0,6.0,6.0,6.0,3.0,0.0,6.0,6.0,0.0,6.0,3.0,0.0,0.0,6.0,6.0,6.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords1), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexTextureCoordBuffer[2]    = 12
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pyramidVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndices   = [  0,1,2,3,5,4,6,7,8,9,10,11]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(cubeVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pyramidVertexIndexBuffer[2]    = 12
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices2   = [  -1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,-1.0,1.0,-1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexPositionBuffer[2]    = 16
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals2   = [  0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexNormalBuffer[2]    = 16
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords2   = [  0.0,0.0,10.0,0.0,10.0,10.0,0.0,10.0,10.0,0.0,10.0,10.0,0.0,10.0,0.0,0.0,10.0,0.0,10.0,10.0,0.0,10.0,0.0,0.0,0.0,0.0,10.0,0.0,10.0,10.0,0.0,10.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords2), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexTextureCoordBuffer[2]    = 16
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cubeVertexIndices   = [  0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(cubeVertexIndices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> cubeVertexIndexBuffer[2]    = 24
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices3   = [  -1.0,-1.0,-1.0,-1.0,-1.0,1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices3), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexPositionBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals3   = [  0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals3), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexNormalBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords3   = [  0.0,10.0,0.0,0.0,10.0,0.0,10.0,10.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords3), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> greenVertexTextureCoordBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexPositionBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  vertices4   = [  -0.2,-1.0,1.001,0.2,-1.0,1.001,-0.2,0.0,1.001,0.2,0.0,1.001]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(vertices4), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexPositionBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexNormalBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  normals4   = [  0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(normals4), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexNormalBuffer[2]    = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  textureCoords4   = [  0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(textureCoords4), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> doorVertexTextureCoordBuffer[2]    = 4
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tractor   = loadObj("models/tractor.obj")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, tractorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(tractor.vertexPositions), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexPositionBuffer[2]    = tractor.vertexPositions.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, tractorVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(tractor.vertexNormals), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexNormalBuffer[2]    = tractor.vertexNormals.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, tractorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(tractor.vertexTextureCoords), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexTextureCoordBuffer[2]    = tractor.vertexTextureCoords.length  /2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tractorVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(tractor.indices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorVertexIndexBuffer[2]    = tractor.indices.length
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  seagul   = loadObj("models/seagul.obj")
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexPositionBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, seagulVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(seagul.vertexPositions), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexPositionBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexPositionBuffer[2]    = seagul.vertexPositions.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexNormalBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, seagulVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(seagul.vertexNormals), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexNormalBuffer[1]    = 3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexNormalBuffer[2]    = seagul.vertexNormals.length  /3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexTextureCoordBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, seagulVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ARRAY_BUFFER, new  , Float32Array(seagul.vertexTextureCoords), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexTextureCoordBuffer[1]    = 2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexTextureCoordBuffer[2]    = seagul.vertexTextureCoords.length  /2
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexIndexBuffer[0]    = gl.createBuffer()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, seagulVertexIndexBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new  , Uint16Array(seagul.indices), gl.STATIC_DRAW)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexIndexBuffer[1]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulVertexIndexBuffer[2]    = seagul.indices.length
[METHOD_DECLARATION] -------> , initTexture : function ( gl )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 6 ; i++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> textures[i]    = gl.createTexture()
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex1   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex1.src    = "images/muro.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex2   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex2)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex2.src    = "images/roof.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex3   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex3)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex3.src    = "images/grass.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex4   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex4)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex4.src    = "images/door.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex5   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex5.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[4])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex5)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex5.src    = "images/tractor.gif"
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tex6   = new  Image()
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex6.onload    = function()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[5])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, tex6)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.generateMipmap(gl.TEXTURE_2D)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, null)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tex6.src    = "images/seagul.gif"
[METHOD_DECLARATION] -------> , drawScene : function ( gl )
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clearColor(0.0, 0.71, 0.91, 1.0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.DEPTH_TEST)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.cullFace(gl.BACK)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[CALL, LINE_OF_CODE] -------> this.handleKeys()
[OPENGL_CALL, LINE_OF_CODE] -------> gl.viewport(0, 0, 500, 500)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.clear(gl.COLOR_BUFFER_BIT  |gl.DEPTH_BUFFER_BIT)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cx   = Math.cos(-pitch)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sx   = Math.sin(-pitch)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cy   = Math.cos(-yaw)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  sy   = Math.sin(-yaw)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pMatrix    = new  Float32Array([  2.4142136573791504,0,0,0,0,2.4142136573791504,0,0,0,0,-1.0020020008087158,-1,0,0,-0.20020020008087158,0])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array([  cy,sx  *sy,-cx*sy,0,0,cx,sx,0,sy,-cy*sx,cx  *cy,0,-cy*xPos  -sy  *zPos,-cx-sx  *sy  *xPos  -cx  *yPos  +cy  *sx  *zPos,-sx+cx  *sy  *xPos  -sx  *yPos  -cx  *cy  *zPos,1])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(ambientColorUniform, 0.1, 0.1, 0.1)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  lightLoc   = new  Float32Array([  0,4,2,1])
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  tlightLoc   = multiplyMatrixVector(pMatrix, multiplyMatrixVector(mvMatrix, lightLoc))
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingLocationUniform, tlightLoc[0], tlightLoc[1], tlightLoc[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingDiffuseColorUniform, 0.5, 0.5, 0.5)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform3f(pointLightingSpecularColorUniform, 0.5, 0.5, 0.5)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1f(materialShininessUniform, 50)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1f(alphaUniform, 1)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.frontFace(gl.CCW)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, cubeVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, doorVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, doorVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, doorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, doorVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[3])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_STRIP, 0, doorVertexPositionBuffer[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.disable(gl.CULL_FACE)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix2    = new  Float32Array(mvMatrix)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[0]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[1]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[2]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[8]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[9]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[10]   * = 10
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, greenVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, greenVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, greenVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, greenVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[2])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawArrays(gl.TRIANGLE_STRIP, 0, greenVertexPositionBuffer[2])
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array(mvMatrix2)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.enable(gl.CULL_FACE)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[13]   + = 2*cx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[14]   + = 2*sx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, pyramidVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, pyramidVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, pyramidVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.activeTexture(gl.TEXTURE0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[1])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pyramidVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, pyramidVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = new  Float32Array(mvMatrix2)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 12 ; i++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[i]   * = 0.01
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  xt   = -11+tractorx
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  yt   = -1
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  zt   = 4
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[12]   + = cy  *xt  +sy  *zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[13]   + = sx  *sy  *xt  +cx  *yt  -cy  *sx  *zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[14]   + = -cx*sy  *xt  +sx  *yt  +cx  *cy  *zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, tractorVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, tractorVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, tractorVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, tractorVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, tractorVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, tractorVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[4])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tractorVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, tractorVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix    = mvMatrix2
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  cs   = Math.cos(seagulAngle)
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  ss   = Math.sin(seagulAngle)
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> xt    = -3*cs  -xPos
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yt    = 2-yPos
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zt    = 4*ss  -zPos
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  s   = 0.3
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[0]    = cs  *cy  *s  -s  *ss  *sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[1]    = cy  *s  *ss  *sx  +cs  *s  *sx  *sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[2]    = -cx*cy  *s  *ss  -cs  *cx  *s  *sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[3]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[4]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[5]    = cx  *s
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[6]    = s  *sx
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[7]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[8]    = cy  *s  *ss  +cs  *s  *sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[9]    = -cs*cy  *s  *sx  +s  *ss  *sx  *sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[10]    = cs  *cx  *cy  *s  -cx  *s  *ss  *sy
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[11]    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[12]    = cy  *xt  +sy  *zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[13]    = -cx+sx  *sy  *xt  +cx  *yt  -cy  *sx  *zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[14]    = -sx-cx  *sy  *xt  +sx  *yt  +cx  *cy  *zt
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> mvMatrix[15]    = 1
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix    = new  Float32Array(9)
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  i  =  0 ; i   < 3 ; i++ )
[FOR, ASSIGNMENT, LINE_OF_CODE] -------> for ( var  j  =  0 ; j   < 3 ; j++ )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> normalMatrix[i  +3*j]    = mvMatrix[i  +4*j]
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, seagulVertexPositionBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexPositionAttribute, seagulVertexPositionBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, seagulVertexNormalBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(vertexNormalAttribute, seagulVertexNormalBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ARRAY_BUFFER, seagulVertexTextureCoordBuffer[0])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.vertexAttribPointer(textureCoordAttribute, seagulVertexTextureCoordBuffer[1], gl.FLOAT, false, 0, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindTexture(gl.TEXTURE_2D, textures[5])
[OPENGL_CALL, LINE_OF_CODE] -------> gl.uniform1i(samplerUniform, 0)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, seagulVertexIndexBuffer[0])
[CALL, LINE_OF_CODE] -------> this.setMatrixUniforms(gl)
[OPENGL_CALL, LINE_OF_CODE] -------> gl.drawElements(gl.TRIANGLES, seagulVertexIndexBuffer[2], gl.UNSIGNED_SHORT, 0)
[CALL, LINE_OF_CODE] -------> this.animate()
[METHOD_DECLARATION] -------> , animate : function (  )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  timeNow   = new  Date().getTime()
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lastTime  !=0 )
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  elapsed   = timeNow  -lastTime
[VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> var  move   = false
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( speed  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> xPos   - = Math.sin(yaw)  *speed  *elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zPos   - = Math.cos(yaw)  *speed  *elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> move    = true
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( lspeed  !=0 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> xPos   + = Math.cos(yaw)  *lspeed  *elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> zPos   - = Math.sin(yaw)  *lspeed  *elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> move    = true
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( move )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> joggingAngle   + = elapsed  *0.0104
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yPos    = Math.sin(joggingAngle)  /20+yStart
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yaw   + = yawRate  *elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitch   + = pitchRate  *elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> seagulAngle   + = 0.0008*elapsed
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorx   + = 0.0008*elapsed
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( tractorx  >22 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> tractorx    = 0
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lastTime    = timeNow
[METHOD_DECLARATION] -------> , handleKeys : function (  )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[0] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = 0.003
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[1] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = -0.003
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> speed    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[2] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = 0.00174
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[3] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = -0.00174
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> pitchRate    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[4] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = 0.00174
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[5] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = -0.00174
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> yawRate    = 0
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( commands[6] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = 0.003
[ELSE, ELSE_IF, ASSIGNMENT, LINE_OF_CODE] ------->  else if ( commands[7] )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = -0.003
[ISOLATED_KEYWORDS] -------> else
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> lspeed    = 0
[METHOD_DECLARATION] -------> , setCommands : function ( e, value )
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==87 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[0]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==83 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[1]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==38 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[2]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==40 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[3]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==37 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[4]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==39 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[5]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==68 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[6]    = value
[IF, ASSIGNMENT, LINE_OF_CODE] ------->  if ( e.keyCode  ==65 )
[VARIABLE_ASSIGNMENT, ASSIGNMENT, LINE_OF_CODE] -------> commands[7]    = value
[METHOD_DECLARATION] -------> , keyPressed : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, true)
[METHOD_DECLARATION] -------> , keyReleased : function ( e )
[CALL, LINE_OF_CODE] -------> this.setCommands(e, false)
